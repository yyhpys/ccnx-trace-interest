<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Content-Centric Networking in Java: org.ccnx.ccn.io.content.Header Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>io</b>.<b>content</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html">Header</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.io.content.Header Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::io::content::Header" --><!-- doxytag: inherits="org::ccnx::ccn::impl::encoding::GenericXMLEncodable,org::ccnx::ccn::impl::encoding::XMLEncodable" -->A <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html" title="A Header is a set of metadata describing a particular CCN stream; basically it provides...">Header</a> is a set of metadata describing a particular CCN stream; basically it provides summary file-level information about that set of content.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for org.ccnx.ccn.io.content.Header:</div>
<div class="dynsection">

<p><center><img src="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.png" usemap="#org.ccnx.ccn.io.content.Header_map" border="0" alt=""></center>
<map name="org.ccnx.ccn.io.content.Header_map">
<area href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html" alt="org.ccnx.ccn.impl.encoding.GenericXMLEncodable" shape="rect" coords="0,56,305,80">
<area href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encodable.html" alt="org.ccnx.ccn.impl.encoding.XMLEncodable" shape="rect" coords="315,56,620,80">
<area href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encodable.html" alt="org.ccnx.ccn.impl.encoding.XMLEncodable" shape="rect" coords="0,0,305,24">
</map>
</div>

<p>
<a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>SegmentationType</b> { <b>SIMPLE_BLOCK</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#9936d9236e798340215d216cd53cec30">Header</a> (long start, long count, int blockSize, long length, byte[] contentDigest, byte[] rootDigest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic constructor for content sequence headers.  <a href="#9936d9236e798340215d216cd53cec30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#1408cc38ab18ddefd9afe2106428c1e6">Header</a> (long length, byte[] contentDigest, byte[] rootDigest, int blockSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic constructor for content sequences.  <a href="#1408cc38ab18ddefd9afe2106428c1e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ceca67aa3333e3792abfa42b71ba0fcb"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::Header" ref="ceca67aa3333e3792abfa42b71ba0fcb" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#ceca67aa3333e3792abfa42b71ba0fcb">Header</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For decoders. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6bced19fa256c88dec3a6deda680f45"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::start" ref="b6bced19fa256c88dec3a6deda680f45" args="()" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>start</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c334cac94659178e42bcf270f8986044"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::count" ref="c334cac94659178e42bcf270f8986044" args="()" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>count</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5970e2687c9baf789232b5abb62541d4"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::blockSize" ref="5970e2687c9baf789232b5abb62541d4" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>blockSize</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8f27f1f9f8195a8e003ae1ed5b88670"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::length" ref="a8f27f1f9f8195a8e003ae1ed5b88670" args="()" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>length</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e427fb2f32e8a702e948cbc12cef96d"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::rootDigest" ref="1e427fb2f32e8a702e948cbc12cef96d" args="()" -->
byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>rootDigest</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df89950ab22833c9daebecfe7f685434"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::contentDigest" ref="df89950ab22833c9daebecfe7f685434" args="()" -->
byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>contentDigest</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95aeeb0fbb29c8d290cf8ff34c5ee11e"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::type" ref="95aeeb0fbb29c8d290cf8ff34c5ee11e" args="()" -->
SegmentationType&nbsp;</td><td class="memItemRight" valign="bottom"><b>type</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="869f1eca4e76033ecae1e16a6a581d27"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::type" ref="869f1eca4e76033ecae1e16a6a581d27" args="(SegmentationType type)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>type</b> (SegmentationType type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="50d39647a37d61718fce0e1ad2ada78a"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::typeName" ref="50d39647a37d61718fce0e1ad2ada78a" args="()" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>typeName</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#d6c31aaaf5f199cdd73f5ebd1bc7de29">decode</a> (<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_decoder.html">XMLDecoder</a> decoder)  throws ContentDecodingException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode this object as the top-level item in a new XML document, reading it from a network buffer.  <a href="#d6c31aaaf5f199cdd73f5ebd1bc7de29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#a89d5a8aee3675b630284ce786a155da">encode</a> (<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encoder.html">XMLEncoder</a> encoder)  throws ContentEncodingException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode this object during an ongoing encoding pass; this is what subclasses generally need to know how to implement.  <a href="#a89d5a8aee3675b630284ce786a155da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#e19abbf26f6918bb84eb00b252dcc272">getElementLabel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow the encoder/decoder to retrieve the top-level element name programmatically.  <a href="#e19abbf26f6918bb84eb00b252dcc272"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#1ad56148ceb894b0e398b72e09a28d2f">validate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure all of the necessary fields are filled in prior to attempting to encode.  <a href="#1ad56148ceb894b0e398b72e09a28d2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d811cce4e664683b1178675a7c6f5e7b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::hashCode" ref="d811cce4e664683b1178675a7c6f5e7b" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>hashCode</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f8f0153ffd73f6a6fc081710d5ca48c"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::equals" ref="2f8f0153ffd73f6a6fc081710d5ca48c" args="(Object obj)" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>equals</b> (Object obj)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b96b28efb1049036d53e95da138190bb"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::positionToSegmentLocation" ref="b96b28efb1049036d53e95da138190bb" args="(long position)" -->
int[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>positionToSegmentLocation</b> (long position)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="554217470d5c914f9b6e8973fe8e0642"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::segmentLocationToPosition" ref="554217470d5c914f9b6e8973fe8e0642" args="(long block, int offset)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>segmentLocationToPosition</b> (long block, int offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="208a0bf419be76fe39b09874ef37070a"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::segmentCount" ref="208a0bf419be76fe39b09874ef37070a" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>segmentCount</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#5d094ef6b0722653f4813965f2dd8a47">segmentRemainder</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of last block.  <a href="#5d094ef6b0722653f4813965f2dd8a47"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55e11d2954854582b6d495279b42f40b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::typeToName" ref="55e11d2954854582b6d495279b42f40b" args="(SegmentationType type)" -->
static String&nbsp;</td><td class="memItemRight" valign="bottom"><b>typeToName</b> (SegmentationType type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2d7c845b616064da5318c007d26a93c1"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::nameToType" ref="2d7c845b616064da5318c007d26a93c1" args="(String name)" -->
static SegmentationType&nbsp;</td><td class="memItemRight" valign="bottom"><b>nameToType</b> (String name)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bff1f5e2a3452dc0200516ea69cd4378"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::_start" ref="bff1f5e2a3452dc0200516ea69cd4378" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#bff1f5e2a3452dc0200516ea69cd4378">_start</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specific to simple block fragmentation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2b7b149138cc3330de62baa631c07871"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::_count" ref="2b7b149138cc3330de62baa631c07871" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>_count</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a02a0cf08e50ec67090310965c84a5e4"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::_blockSize" ref="a02a0cf08e50ec67090310965c84a5e4" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>_blockSize</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="65eb11fa78ff48aa2de5c25883b8ad8d"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::_length" ref="65eb11fa78ff48aa2de5c25883b8ad8d" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>_length</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ada69c5ad9ec85031f5059b982d2bbcc"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::_type" ref="ada69c5ad9ec85031f5059b982d2bbcc" args="" -->
SegmentationType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#ada69c5ad9ec85031f5059b982d2bbcc">_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68da400dd2336e581fb988267d38c555"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::_contentDigest" ref="68da400dd2336e581fb988267d38c555" args="" -->
byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>_contentDigest</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd8f147243bfe238dab7b20b9aab888e"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::_rootDigest" ref="dd8f147243bfe238dab7b20b9aab888e" args="" -->
byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>_rootDigest</b></td></tr>

<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f6d4a714f86fce860cbcce5deaa7d1b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::SegmentationTypeNames" ref="6f6d4a714f86fce860cbcce5deaa7d1b" args="" -->
static final HashMap<br>
&lt; SegmentationType, String &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>SegmentationTypeNames</b> = new HashMap&lt;SegmentationType, String&gt;()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d201f5b4fd4e0bed86c76688da1283e0"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::SegmentationNameTypes" ref="d201f5b4fd4e0bed86c76688da1283e0" args="" -->
static final HashMap&lt; String, <br>
SegmentationType &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>SegmentationNameTypes</b> = new HashMap&lt;String, SegmentationType&gt;()</td></tr>

<tr><td colspan="2"><br><h2>Static Package Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="39561432ccb2357caa901bf3513c682f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::[static initializer]" ref="39561432ccb2357caa901bf3513c682f" args="" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>[static initializer]</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header_1_1_header_object.html">HeaderObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A CCNNetworkObject wrapper around <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html" title="A Header is a set of metadata describing a particular CCN stream; basically it provides...">Header</a>, used for easily saving and retrieving versioned Headers to CCN.  <a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header_1_1_header_object.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html" title="A Header is a set of metadata describing a particular CCN stream; basically it provides...">Header</a> is a set of metadata describing a particular CCN stream; basically it provides summary file-level information about that set of content. 
<p>
It is usually stored and read by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_output_stream.html" title="A versioned output stream that adds a header containing file-level metadata to every...">CCNFileOutputStream</a> and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html" title="A CCN input stream that expects content names to be versioned, and streams to have...">CCNFileInputStream</a> and their subclasses, rather than being created directly by clients.<p>
A number of the segmentation-related definitions currently found in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html" title="A Header is a set of metadata describing a particular CCN stream; basically it provides...">Header</a> will eventually move to the SegmentationProfile. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="9936d9236e798340215d216cd53cec30"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::Header" ref="9936d9236e798340215d216cd53cec30" args="(long start, long count, int blockSize, long length, byte[] contentDigest, byte[] rootDigest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.content.Header.Header           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>contentDigest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>rootDigest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Basic constructor for content sequence headers. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The starting byte offset for this file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of blocks. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>The size of blocks (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The total length of the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentDigest</em>&nbsp;</td><td>For convenience, the digest of the unsegmented content. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rootDigest</em>&nbsp;</td><td>The root digest of the bulk signature tree for the content (Merkle Hash Tree). This turns out to be less useful than you'd think as there are typically multiple MHT's per file, and is likely to be removed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1408cc38ab18ddefd9afe2106428c1e6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::Header" ref="1408cc38ab18ddefd9afe2106428c1e6" args="(long length, byte[] contentDigest, byte[] rootDigest, int blockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.content.Header.Header           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>contentDigest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>rootDigest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Basic constructor for content sequences. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The total length of the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentDigest</em>&nbsp;</td><td>For convenience, the digest of the unsegmented content. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rootDigest</em>&nbsp;</td><td>The root digest of the bulk signature tree for the content (Merkle Hash Tree). This turns out to be less useful than you'd think as there are typically multiple MHT's per file, and is likely to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>The size of blocks (in bytes). </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d6c31aaaf5f199cdd73f5ebd1bc7de29"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::decode" ref="d6c31aaaf5f199cdd73f5ebd1bc7de29" args="(XMLDecoder decoder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.Header.decode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_decoder.html">XMLDecoder</a>&nbsp;</td>
          <td class="paramname"> <em>decoder</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws ContentDecodingException <code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode this object as the top-level item in a new XML document, reading it from a network buffer. 
<p>
Reads document start and end. Assumes default encoding. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>input stream to read from </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td>if there is an error decoding the content Decode this object as the top-level item in a new XML document, reading it from a network buffer. Reads document start and end. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>input stream to read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>codec</em>&nbsp;</td><td>the codec to use; must be recognized by XMLCodecFactory </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td>if there is an error decoding the content</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>XMLCodecFactory Decode this object during an ongoing decoding pass; this is what subclasses generally need to know how to implement. Reads just the object itself, higher-level processes have handled start and end document if need be. Allows object to be read using the same code whether it is a top-level element written alone, or nested inside another element. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>decoder</em>&nbsp;</td><td>the decoder being used; encapsulates state including the codec being used as well as the input source and current offset </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#2742f46432cfddb297c88300b3b93ebd">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div><p>
<a class="anchor" name="a89d5a8aee3675b630284ce786a155da"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::encode" ref="a89d5a8aee3675b630284ce786a155da" args="(XMLEncoder encoder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.Header.encode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encoder.html">XMLEncoder</a>&nbsp;</td>
          <td class="paramname"> <em>encoder</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws ContentEncodingException <code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode this object during an ongoing encoding pass; this is what subclasses generally need to know how to implement. 
<p>
Writes just the object itself, higher-level processes have handled start and end document if need be. Allows object to be written using the same code whether it is a top-level element written alone, or nested inside another element. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>encoder</em>&nbsp;</td><td>the encoder being used; encapsulates state including the codec being used as well as the output destination and current offset </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#eb997279d10d18277cab484de7edf741">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div><p>
<a class="anchor" name="e19abbf26f6918bb84eb00b252dcc272"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::getElementLabel" ref="e19abbf26f6918bb84eb00b252dcc272" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.content.Header.getElementLabel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow the encoder/decoder to retrieve the top-level element name programmatically. 
<p>
This allows subclasses to rename elements without changing their encoder/decoders. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the element label to use, as a key in a loaded encoding dictionary </dd></dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#643e91ecff8b7ed820063e7537e23acd">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div><p>
<a class="anchor" name="1ad56148ceb894b0e398b72e09a28d2f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::validate" ref="1ad56148ceb894b0e398b72e09a28d2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.Header.validate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure all of the necessary fields are filled in prior to attempting to encode. 
<p>
All implementations of <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html#a89d5a8aee3675b630284ce786a155da" title="Encode this object during an ongoing encoding pass; this is what subclasses generally...">encode(XMLEncoder)</a> should call this for their classes prior to encoding. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if object is valid and can be encoded, false if there is a problem; for example mandatory fields are uninitialized </dd></dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#0cc2a6cf56f0853fa0ab1c514b65e6b6">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div><p>
<a class="anchor" name="5d094ef6b0722653f4813965f2dd8a47"></a><!-- doxytag: member="org::ccnx::ccn::io::content::Header::segmentRemainder" ref="5d094ef6b0722653f4813965f2dd8a47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.io.content.Header.segmentRemainder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Length of last block. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/io/content/Header.java</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Sep 14 12:44:29 2011 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
