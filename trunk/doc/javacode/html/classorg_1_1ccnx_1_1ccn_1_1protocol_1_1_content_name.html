<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Content-Centric Networking in Java: org.ccnx.ccn.protocol.ContentName Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>protocol</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.protocol.ContentName Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::protocol::ContentName" --><!-- doxytag: inherits="org::ccnx::ccn::impl::encoding::GenericXMLEncodable,org::ccnx::ccn::impl::encoding::XMLEncodable,Comparable,java::io::Serializable" -->ContentNames consist of a sequence of byte[] components which may not be assumed to follow any string encoding, or any other particular encoding.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for org.ccnx.ccn.protocol.ContentName:</div>
<div class="dynsection">

<p><center><img src="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.png" usemap="#org.ccnx.ccn.protocol.ContentName_map" border="0" alt=""></center>
<map name="org.ccnx.ccn.protocol.ContentName_map">
<area href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html" alt="org.ccnx.ccn.impl.encoding.GenericXMLEncodable" shape="rect" coords="0,56,370,80">
<area href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encodable.html" alt="org.ccnx.ccn.impl.encoding.XMLEncodable" shape="rect" coords="380,56,750,80">
<area href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encodable.html" alt="org.ccnx.ccn.impl.encoding.XMLEncodable" shape="rect" coords="0,0,370,24">
<area href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_interest_table_3_01_v_01_4_1_1_longest_first_content_name.html" alt="org.ccnx.ccn.impl.InterestTable< V >.LongestFirstContentName" shape="rect" coords="190,168,560,192">
<area href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapping_key_name.html" alt="org.ccnx.ccn.io.content.WrappingKeyName" shape="rect" coords="570,168,940,192">
</map>
</div>

<p>
<a href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="453549551f171570ed5a14d0e69ad4f3"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="453549551f171570ed5a14d0e69ad4f3" args="(byte components[][])" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>ContentName</b> (byte components[][])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#c82a768387934a5ab95d14a9fa97f404">ContentName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, byte[] name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor given another <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a>, appends an extra component.  <a href="#c82a768387934a5ab95d14a9fa97f404"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#104d43833e2876fbc45b8e58645be275">ContentName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, byte[][] childComponents)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor given another <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a>, appends extra components.  <a href="#104d43833e2876fbc45b8e58645be275"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#1a17bdd1e09bf36085a965c553763a9d">ContentName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, ArrayList&lt; byte[]&gt; childComponents)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Now that components() returns an ArrayList&lt;byte []&gt;, make a constructor that takes that as input.  <a href="#1a17bdd1e09bf36085a965c553763a9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#a5e9596293ae82d2dd8925de4e53046a">ContentName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, int start, ArrayList&lt; byte[]&gt; childComponents)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">parent is base name, then add components from childComponets starting at index "start".  <a href="#a5e9596293ae82d2dd8925de4e53046a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d38fe104a663832f500358c6f1b5cbab"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="d38fe104a663832f500358c6f1b5cbab" args="(ContentName parent, byte[] name1, byte[] name2)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>ContentName</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, byte[] name1, byte[] name2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#5e3a6d2644182ff24fcc015e9f50e8ad">ContentName</a> (int count, byte components[][])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for extending or contracting names.  <a href="#5e3a6d2644182ff24fcc015e9f50e8ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#4b8e2785348b8dfcab88c9b2d56484e9">ContentName</a> (int count, ArrayList&lt; byte[]&gt;components)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for extending or contracting names.  <a href="#4b8e2785348b8dfcab88c9b2d56484e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#7181240a43890d4a5c4f563fd99e8a86">ContentName</a> (int start, int count, ArrayList&lt; byte[]&gt;components)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subname constructor for extending or contracting names, extracts particular subcomponents from an existing set.  <a href="#7181240a43890d4a5c4f563fd99e8a86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#d5fdfc96e72c86eca8cb162334d67b40">ContentName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> otherName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor, also used by subclasses merely wanting a different name in encoding/decoding.  <a href="#d5fdfc96e72c86eca8cb162334d67b40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b24e25ea213ab8e0930c2ca5e593bbf"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::clone" ref="1b24e25ea213ab8e0930c2ca5e593bbf" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>clone</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c4046d50770b26076d92712783490845"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::parent" ref="c4046d50770b26076d92712783490845" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#c4046d50770b26076d92712783490845">parent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new name with the last component removed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#5ba86bb3c5f79a1f2a69fcbfd5646cc3">toString</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#5ba86bb3c5f79a1f2a69fcbfd5646cc3" title="Default toString() implementation simply prints the text encoding of the object.">toString()</a> implementation simply prints the text encoding of the object.  <a href="#5ba86bb3c5f79a1f2a69fcbfd5646cc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#d7526247f5f3db81a48d6c0ce6a16f5b">toURIString</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print as string with scheme in front.  <a href="#d7526247f5f3db81a48d6c0ce6a16f5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c7848b29521e201a629a9cca842a64d9"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::components" ref="c7848b29521e201a629a9cca842a64d9" args="()" -->
ArrayList&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>components</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#2c37232993cb5d49fda3cd7236e4c04e">count</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="652f5bf72f8a6c19d9352b22acd272e8"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::append" ref="652f5bf72f8a6c19d9352b22acd272e8" args="(ContentName other)" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#652f5bf72f8a6c19d9352b22acd272e8">append</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a segmented name to this name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#44ecdea3e9e9b7570e9817f750a65dba">append</a> (String postfix)  throws MalformedContentNameStringException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a name to this one, where the child name might have more than one path component -- e.g.  <a href="#44ecdea3e9e9b7570e9817f750a65dba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">final byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#c38de7d4627e6daedc17733c6317a047">component</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the i'th component, indexed from 0.  <a href="#c38de7d4627e6daedc17733c6317a047"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="11b64748a170763e66bd7f9a3abefbdd"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::lastComponent" ref="11b64748a170763e66bd7f9a3abefbdd" args="()" -->
final byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>lastComponent</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#438b8be863101b1da5811e9a4236c19a">stringComponent</a> (int i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#b1dbcc53da398515191bbebe34293558">decode</a> (<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_decoder.html">XMLDecoder</a> decoder)  throws ContentDecodingException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by NetworkObject to decode the object from a network stream.  <a href="#b1dbcc53da398515191bbebe34293558"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#2d893fc8a09eedb145b89d56e7758c8b">isPrefixOf</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this name is a prefix of another name - i.e.  <a href="#2d893fc8a09eedb145b89d56e7758c8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#9b1ef8aaf1b74a4b1304aa5a3f711775">isPrefixOf</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests if the first n components are a prefix of name.  <a href="#9b1ef8aaf1b74a4b1304aa5a3f711775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#491e988e4762b4809f4c9bfdac100d12">isPrefixOf</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare our name to the name of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html" title="Represents a CCNx data packet.">ContentObject</a>.  <a href="#491e988e4762b4809f4c9bfdac100d12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d44deeb977588c0675b6bfa20a371799"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::isPrefixOf" ref="d44deeb977588c0675b6bfa20a371799" args="(ContentObject other, int count)" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>isPrefixOf</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> other, int count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="70b14c578b76a45dd6fe181a1fa4eaa4"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::equals" ref="70b14c578b76a45dd6fe181a1fa4eaa4" args="(Object obj)" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#70b14c578b76a45dd6fe181a1fa4eaa4">equals</a> (Object obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hashCode and equals not auto-generated, ArrayList does not do the right thing. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="459401cd4d367a80614f94cabe672746"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::hashCode" ref="459401cd4d367a80614f94cabe672746" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>hashCode</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#a58ca758313d641e311b1b8ba49e1d22">contains</a> (String str)  throws URISyntaxException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses the canonical URI representation.  <a href="#a58ca758313d641e311b1b8ba49e1d22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0992e7fa97b6167128ef1d42c770c0ab"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::contains" ref="0992e7fa97b6167128ef1d42c770c0ab" args="(byte[] component)" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>contains</b> (byte[] component)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#346f11d9e671037e98e212463ee0a895">containsWhere</a> (String str)  throws URISyntaxException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for a component.  <a href="#346f11d9e671037e98e212463ee0a895"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#c8eabead5de9feb55a5ebe877f89d811">whereLast</a> (String str)  throws URISyntaxException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for a component, starting from the end.  <a href="#c8eabead5de9feb55a5ebe877f89d811"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#ba6333be47fd3239deb19e0ae0b3d91f">containsWhere</a> (byte[] component)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return component index of the first matching component if it exists.  <a href="#ba6333be47fd3239deb19e0ae0b3d91f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#f2ff1e775ada6d5236f97ad263b202f9">whereLast</a> (byte[] component)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return component index of the last matching component if it exists.  <a href="#f2ff1e775ada6d5236f97ad263b202f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#bcd8206fc0efc153268d099a00c5f385">startsWith</a> (byte[] value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does a component of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a> startWith value?  <a href="#bcd8206fc0efc153268d099a00c5f385"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#ed516235f039003d4a2c537bfdc15661">startsWithWhere</a> (byte[] value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return component index of first component that starts with argument value.  <a href="#ed516235f039003d4a2c537bfdc15661"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#a0e5688e740e866cb397bc04315c7c8b">cut</a> (int componentCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first componentNumber components of this name as a new name.  <a href="#a0e5688e740e866cb397bc04315c7c8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#fef295d847bdff9f86d138eb6c4b1f0f">cut</a> (byte[] component)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slice the name off right before the given component.  <a href="#fef295d847bdff9f86d138eb6c4b1f0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#d496516ccc9e6ae69713c21f55d0d9d3">cut</a> (String component)  throws URISyntaxException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slice the name off right before the given component.  <a href="#d496516ccc9e6ae69713c21f55d0d9d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#69ffdeb5082a6b99c3c1c066977b349e">subname</a> (int start, int componentCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a subname of this name as a new name.  <a href="#69ffdeb5082a6b99c3c1c066977b349e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#5bf8f640c9dbc90e822e64d3d9810bc5">postfix</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the remainder of this name after the prefix, if the prefix is a prefix of this name.  <a href="#5bf8f640c9dbc90e822e64d3d9810bc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#cafaac1100675191a699b60d1d8fce3b">encode</a> (<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encoder.html">XMLEncoder</a> encoder)  throws ContentEncodingException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by NetworkObject to encode the object to a network stream.  <a href="#cafaac1100675191a699b60d1d8fce3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#335255b177f49718b4643380c89083b9">validate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure all of the necessary fields are filled in prior to attempting to encode.  <a href="#335255b177f49718b4643380c89083b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#e853328e7f894b9c21d9c60e24443d1b">getElementLabel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow the encoder/decoder to retrieve the top-level element name programmatically.  <a href="#e853328e7f894b9c21d9c60e24443d1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83bb506df4a09da0b806d941ba236d24"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::copy" ref="83bb506df4a09da0b806d941ba236d24" args="(int nameComponentCount)" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>copy</b> (int nameComponentCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9465abfc957d6033f5fd0e54c204369d"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::compareTo" ref="9465abfc957d6033f5fd0e54c204369d" args="(ContentName o)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compareTo</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> o)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#126a4d0d84ec7403d3e8d489a2e0f89a">fromURI</a> (String name)  throws MalformedContentNameStringException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> represented by the given URI.  <a href="#126a4d0d84ec7403d3e8d489a2e0f89a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#2a9592e4cc6aaeb7b75f04dca65cbcc3">fromURI</a> (String parts[])  throws MalformedContentNameStringException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an array of strings, apply URI decoding and create a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a>.  <a href="#2a9592e4cc6aaeb7b75f04dca65cbcc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#cc6f761e042b19ca1143726f4028a754">fromURI</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, String name)  throws MalformedContentNameStringException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> created by appending one component to the supplied parent.  <a href="#cc6f761e042b19ca1143726f4028a754"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#8d2b561c12b7db8497f6a9a6cc9041e2">fromNative</a> (String name)  throws MalformedContentNameStringException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> created from a native Java String.  <a href="#8d2b561c12b7db8497f6a9a6cc9041e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#a9dbd18de85ecfa52b04977b8995bb59">fromNative</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, String name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> created by appending one component to the supplied parent.  <a href="#a9dbd18de85ecfa52b04977b8995bb59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c140c92a75cb5126c56436827ffa0c1"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromNative" ref="5c140c92a75cb5126c56436827ffa0c1" args="(ContentName parent, byte[] name)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fromNative</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, byte[] name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d73e9cd3bec09c127e1616e517920050"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromNative" ref="d73e9cd3bec09c127e1616e517920050" args="(ContentName parent, String name1, String name2)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fromNative</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, String name1, String name2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2836f7593130eb8a4ed1d35ca81f761"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromNative" ref="c2836f7593130eb8a4ed1d35ca81f761" args="(String[] parts)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fromNative</b> (String[] parts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05a7655675f9bc43eeb040331f618323"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromNative" ref="05a7655675f9bc43eeb040331f618323" args="(ContentName parent, String[] parts)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fromNative</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> parent, String[] parts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#6ebe0e78d2d330f7a875105dd693a9cb">componentPrintURI</a> (byte[] bs, int offset, int length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print bytes in the URI Generic Syntax of RFC 3986 including byte sequences that are not legal character encodings in any character set and byte sequences that have special meaning for URI resolution per RFC 3986.  <a href="#6ebe0e78d2d330f7a875105dd693a9cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c25404453618f0d044ec4f830c4ccb5"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::componentPrintURI" ref="2c25404453618f0d044ec4f830c4ccb5" args="(byte[] bs)" -->
static String&nbsp;</td><td class="memItemRight" valign="bottom"><b>componentPrintURI</b> (byte[] bs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad0f408dc3b9e91816e7cf5bbcf2b712"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::componentPrintNative" ref="ad0f408dc3b9e91816e7cf5bbcf2b712" args="(byte[] bs)" -->
static String&nbsp;</td><td class="memItemRight" valign="bottom"><b>componentPrintNative</b> (byte[] bs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af57d4f6cbb670bad9df3ca097e2ea4a"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::hexPrint" ref="af57d4f6cbb670bad9df3ca097e2ea4a" args="(byte[] bs)" -->
static String&nbsp;</td><td class="memItemRight" valign="bottom"><b>hexPrint</b> (byte[] bs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#eaab08c2f662539819a993809567f74e">componentParseURI</a> (String name)  throws DotDotComponent, URISyntaxException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the URI Generic Syntax of RFC 3986.  <a href="#eaab08c2f662539819a993809567f74e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#ed305fde966678b6a97bff5f6ebf20cd">componentParseNative</a> (String name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse native string component: just UTF-8 encode For full names in native strings only "/" is special but for an individual component we will even allow that.  <a href="#ed305fde966678b6a97bff5f6ebf20cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#88711707916bda3afc72eb59251672d7">parse</a> (String str)  throws MalformedContentNameStringException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses the canonical URI representation.  <a href="#88711707916bda3afc72eb59251672d7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e3d90d55867cc6f890434fdd5f27bc36"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::SCHEME" ref="e3d90d55867cc6f890434fdd5f27bc36" args="" -->
static final String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#e3d90d55867cc6f890434fdd5f27bc36">SCHEME</a> = &quot;ccnx:&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Official CCN URI scheme. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d9f1b6f668dddfd31fa825356588d38"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ORIGINAL_SCHEME" ref="3d9f1b6f668dddfd31fa825356588d38" args="" -->
static final String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#3d9f1b6f668dddfd31fa825356588d38">ORIGINAL_SCHEME</a> = &quot;ccn:&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This scheme has been deprecated, but we still want to accept it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87dfe027e02ea454c5925b2424333aab"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::SEPARATOR" ref="87dfe027e02ea454c5925b2424333aab" args="" -->
static final String&nbsp;</td><td class="memItemRight" valign="bottom"><b>SEPARATOR</b> = &quot;/&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="42ec408b18ef48ae508112285dc26831"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ROOT" ref="42ec408b18ef48ae508112285dc26831" args="" -->
static final <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ROOT</b> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>(0, (ArrayList&lt;byte []&gt;)null)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a221f0c07a21da0650f857097bb69324"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::_components" ref="a221f0c07a21da0650f857097bb69324" args="" -->
ArrayList&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>_components</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>DotDotComponent</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
ContentNames consist of a sequence of byte[] components which may not be assumed to follow any string encoding, or any other particular encoding. 
<p>
The constructors therefore provide for creation only from byte[]s. To create a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a> from Strings, a client must call one of the static methods that implements a conversion. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c82a768387934a5ab95d14a9fa97f404"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="c82a768387934a5ab95d14a9fa97f404" args="(ContentName parent, byte[] name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.protocol.ContentName.ContentName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor given another <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a>, appends an extra component. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>used for the base of the name, if null, no prefix added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>component to be appended; if null, just copy parent </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="104d43833e2876fbc45b8e58645be275"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="104d43833e2876fbc45b8e58645be275" args="(ContentName parent, byte[][] childComponents)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.protocol.ContentName.ContentName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bytechildComponents&nbsp;</td>
          <td class="paramname">[][]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor given another <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a>, appends extra components. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>used for the base of the name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>childComponents</em>&nbsp;</td><td>components to be appended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1a17bdd1e09bf36085a965c553763a9d"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="1a17bdd1e09bf36085a965c553763a9d" args="(ContentName parent, ArrayList&lt; byte[]&gt; childComponents)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.protocol.ContentName.ContentName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; byte[]&gt;&nbsp;</td>
          <td class="paramname"> <em>childComponents</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Now that components() returns an ArrayList&lt;byte []&gt;, make a constructor that takes that as input. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>used for the base of the name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>childComponents</em>&nbsp;</td><td>the additional name components to add at the end of parent </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a5e9596293ae82d2dd8925de4e53046a"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="a5e9596293ae82d2dd8925de4e53046a" args="(ContentName parent, int start, ArrayList&lt; byte[]&gt; childComponents)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.protocol.ContentName.ContentName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; byte[]&gt;&nbsp;</td>
          <td class="paramname"> <em>childComponents</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parent is base name, then add components from childComponets starting at index "start". 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>used for the base of the name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>index in childComponents to begin adding from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>childComponents</em>&nbsp;</td><td>the additional name components to add at the end of parent </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5e3a6d2644182ff24fcc015e9f50e8ad"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="5e3a6d2644182ff24fcc015e9f50e8ad" args="(int count, byte components[][])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.protocol.ContentName.ContentName           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>components</em>[][]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for extending or contracting names. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>only this number of name components are taken from components. If count exceeds the number of components passed all components will be included and additional space will be preallocated in the representation for subsequent addition of components. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>components</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4b8e2785348b8dfcab88c9b2d56484e9"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="4b8e2785348b8dfcab88c9b2d56484e9" args="(int count, ArrayList&lt; byte[]&gt;components)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.protocol.ContentName.ContentName           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; byte[]&gt;&nbsp;</td>
          <td class="paramname"> <em>components</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for extending or contracting names. 
<p>
Performs a faster shallow copy of the components, as we don't tend to alter name components once created. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Only this number of name components are copied into the new name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>components</em>&nbsp;</td><td>These are the name components to be copied. Can be null, empty, or longer or shorter than count. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7181240a43890d4a5c4f563fd99e8a86"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="7181240a43890d4a5c4f563fd99e8a86" args="(int start, int count, ArrayList&lt; byte[]&gt;components)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.protocol.ContentName.ContentName           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; byte[]&gt;&nbsp;</td>
          <td class="paramname"> <em>components</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subname constructor for extending or contracting names, extracts particular subcomponents from an existing set. 
<p>
Performs a faster shallow copy of the components, as we don't tend to alter name components once created. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>This is index (0-based) of the first component to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Only this number of name components are copied into the new name. If count-start is greater than the last component in the components array, only copies count-start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>components</em>&nbsp;</td><td>These are the name components to be copied. Can be null, empty, or longer or shorter than count. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d5fdfc96e72c86eca8cb162334d67b40"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::ContentName" ref="d5fdfc96e72c86eca8cb162334d67b40" args="(ContentName otherName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.protocol.ContentName.ContentName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>otherName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor, also used by subclasses merely wanting a different name in encoding/decoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherName</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="126a4d0d84ec7403d3e8d489a2e0f89a"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromURI" ref="126a4d0d84ec7403d3e8d489a2e0f89a" args="(String name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.fromURI           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a> <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> represented by the given URI. 
<p>
A CCN <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> consists of a sequence of binary components of any length (including 0), which allows such things as encrypted name components. It is often convenient to work with string representations of names in various forms. <p>
The canonical String representation of a CCN <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> is a URI encoding of the name according to RFC 3986 with the addition of special treatment for name components of 0 length or containing only one or more of the byte value 0x2E, which is the US-ASCII encoding of '.'. The major features of the URI encoding are the use of a limited set of characters and the use of percent-encoding to encode all other byte values. The combination of percent-encoding and special treatment for certain name components allows the canonical CCN string representation to encode all possible CCN names. <p>
The legal characters in the URI are limited to the <em>unreserved</em> characters "a" through "z", "A" through "Z", "0" through "9", and "-", "_", ".", and "~" plus the <em>reserved</em> delimiters "!", "$" "&amp;", "'", "(", ")", "*", "+", ",", ";", "=". The reserved delimiter "/" is a special case interpreted as component separator and so may not be used within a component unescaped. Any query (starting '?') or fragment (starting '#') is ignored which means that these reserved delimiters must be percent-encoded if they are to be part of the name. <p>
The URI must begin with either the "/" delimiter or the scheme specification "ccnx:" plus delimiter to make URI absolute. <p>
The decoding from a URI String to a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a> translates each legal character to its US-ASCII byte encoding, except for the "." which is subject to special handling described below. Any other byte value in a component (including those corresponding to "/" and ":") must be percent-encoded in the URI. Any character sequence starting with "?" or "#" is discarded (to the end of the component). <p>
The resolution rules for relative references are applied in this decoding: <ul>
<li>
"//" in the URI is interpreted as "/" </li>
<li>
"/./" and "/." in the URI are interpreted as "/" and "" </li>
<li>
"/../" and "/.." in the URI are interpreted as removing the preceding component </li>
</ul>
<p>
Any component of 0 length, or containing only one or more of the byte value 0x2E ("."), is represented in the URI by one "." per byte plus the suffix "..." which provides unambiguous representation of all possible name components in conjunction with the use of the resolution rules given above. Thus the decoding from URI String to <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a> makes conversions such as: <ul>
<li>
"/.../" in the URI is converted to a 0-length name component </li>
<li>
"/..../" in the URI is converted to the name component {0x2E} </li>
<li>
"/...../" in the URI is converted to the name component {0x2E, 0x2E} </li>
<li>
"/....../" in the URI is converted to the name component {0x2E, 0x2E, 0x2E} </li>
</ul>
<p>
Note that this URI encoding is very similar to but not the same as the application/x-www-form-urlencoded MIME format that is used by the Java java.net.URLDecoder.<p>
TODO: Inconsistent with C lib in that it does not strip authority part TODO: Inconsistent with C lib in that it does not fully strip query and fragment parts (within component only) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2a9592e4cc6aaeb7b75f04dca65cbcc3"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromURI" ref="2a9592e4cc6aaeb7b75f04dca65cbcc3" args="(String parts[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.fromURI           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>parts</em>[]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a> <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an array of strings, apply URI decoding and create a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#126a4d0d84ec7403d3e8d489a2e0f89a" title="Return the ContentName represented by the given URI.">fromURI(String)</a> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cc6f761e042b19ca1143726f4028a754"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromURI" ref="cc6f761e042b19ca1143726f4028a754" args="(ContentName parent, String name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.fromURI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a> <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> created by appending one component to the supplied parent. 
<p>
The new component is converted from URI string encoding. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#126a4d0d84ec7403d3e8d489a2e0f89a" title="Return the ContentName represented by the given URI.">fromURI(String)</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>used for the base of the name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>sequence of URI encoded name components, appended to the base. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8d2b561c12b7db8497f6a9a6cc9041e2"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromNative" ref="8d2b561c12b7db8497f6a9a6cc9041e2" args="(String name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.fromNative           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a> <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> created from a native Java String. 
<p>
In native strings only "/" is special, interpreted as component delimiter, while all other characters will be encoded as UTF-8 in the output <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> Native String representations do not incorporate a URI scheme, and so must begin with the component delimiter "/". TODO use Java string escaping rules? <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a></em>&nbsp;</td><td>if name does not start with "/" </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a9dbd18de85ecfa52b04977b8995bb59"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::fromNative" ref="a9dbd18de85ecfa52b04977b8995bb59" args="(ContentName parent, String name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.fromNative           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> created by appending one component to the supplied parent. 
<p>
This method intentionally throws no declared exceptions so you can be confident in encoding any native Java String. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>used for the base of the name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Native Java String which will be encoded as UTF-8 in the output <code><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a></code> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5ba86bb3c5f79a1f2a69fcbfd5646cc3"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::toString" ref="5ba86bb3c5f79a1f2a69fcbfd5646cc3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String org.ccnx.ccn.protocol.ContentName.toString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#5ba86bb3c5f79a1f2a69fcbfd5646cc3" title="Default toString() implementation simply prints the text encoding of the object.">toString()</a> implementation simply prints the text encoding of the object. 
<p>
This demonstrates how to force use of the text encoding. 
<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#00d055c850c6ad0a48f5e3cdbe8e22b5">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div><p>
<a class="anchor" name="d7526247f5f3db81a48d6c0ce6a16f5b"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::toURIString" ref="d7526247f5f3db81a48d6c0ce6a16f5b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String org.ccnx.ccn.protocol.ContentName.toURIString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print as string with scheme in front. 
<p>
toString already prints in URI format with leading /, just add scheme. 
</div>
</div><p>
<a class="anchor" name="6ebe0e78d2d330f7a875105dd693a9cb"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::componentPrintURI" ref="6ebe0e78d2d330f7a875105dd693a9cb" args="(byte[] bs, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static String org.ccnx.ccn.protocol.ContentName.componentPrintURI           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print bytes in the URI Generic Syntax of RFC 3986 including byte sequences that are not legal character encodings in any character set and byte sequences that have special meaning for URI resolution per RFC 3986. 
<p>
This is designed to match the C library URI encoding.<p>
This method must be invertible by parseComponent() so for any input sequence of bytes it must be the case that parseComponent(printComponent(input)) == input.<p>
All bytes that are unreserved characters per RFC 3986 are left unescaped. Other bytes are percent encoded.<p>
Empty path components and path components "." and ".." have special meaning for relative URI resolution per RFC 3986. To guarantee these component variations are preserved and recovered exactly when the URI is parsed by parseComponent() we use a convention that components that are empty or consist entirely of '.' characters will have "..." appended. This is intended to be consistent with the CCN C library handling of URI representation of names. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bs</em>&nbsp;</td><td>input byte array. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="eaab08c2f662539819a993809567f74e"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::componentParseURI" ref="eaab08c2f662539819a993809567f74e" args="(String name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] org.ccnx.ccn.protocol.ContentName.componentParseURI           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws DotDotComponent, URISyntaxException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse the URI Generic Syntax of RFC 3986. 
<p>
Including handling percent encoding of sequences that are not legal character encodings in any character set. This method is the inverse of printComponent() and for any input sequence of bytes it must be the case that parseComponent(printComponent(input)) == input. Note that the inverse is NOT true printComponent(parseComponent(input)) != input in general.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#126a4d0d84ec7403d3e8d489a2e0f89a" title="Return the ContentName represented by the given URI.">fromURI(String)</a></dd></dl>
Note in particular that this method interprets sequences of more than two dots ('.') as representing an empty component or dot component value as encoded by componentPrint. That is, the component value will be the value obtained by removing three dots. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>a single component of a name, URI encoded </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a name component </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed305fde966678b6a97bff5f6ebf20cd"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::componentParseNative" ref="ed305fde966678b6a97bff5f6ebf20cd" args="(String name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] org.ccnx.ccn.protocol.ContentName.componentParseNative           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse native string component: just UTF-8 encode For full names in native strings only "/" is special but for an individual component we will even allow that. 
<p>
This method intentionally throws no declared exceptions so you can be confident in encoding any native Java String TODO make this use Java string escaping rules? <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Component as native Java string </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2c37232993cb5d49fda3cd7236e4c04e"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::count" ref="2c37232993cb5d49fda3cd7236e4c04e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.protocol.ContentName.count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of components in the name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="44ecdea3e9e9b7570e9817f750a65dba"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::append" ref="44ecdea3e9e9b7570e9817f750a65dba" args="(String postfix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.append           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>postfix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a name to this one, where the child name might have more than one path component -- e.g. 
<p>
foo/bar/bash. Will add leading / to postfix for parsing, if one not present. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c38de7d4627e6daedc17733c6317a047"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::component" ref="c38de7d4627e6daedc17733c6317a047" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final byte [] org.ccnx.ccn.protocol.ContentName.component           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the i'th component, indexed from 0. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>null if i is out of range. </dd></dl>

</div>
</div><p>
<a class="anchor" name="438b8be863101b1da5811e9a4236c19a"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::stringComponent" ref="438b8be863101b1da5811e9a4236c19a" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String org.ccnx.ccn.protocol.ContentName.stringComponent           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The i'th component, converted using URI encoding. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b1dbcc53da398515191bbebe34293558"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::decode" ref="b1dbcc53da398515191bbebe34293558" args="(XMLDecoder decoder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.protocol.ContentName.decode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_decoder.html">XMLDecoder</a>&nbsp;</td>
          <td class="paramname"> <em>decoder</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws ContentDecodingException <code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used by NetworkObject to decode the object from a network stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encodable.html" title="Top-level interface implemented by objects that want to make use of our stream encoding...">org.ccnx.ccn.impl.encoding.XMLEncodable</a> </dd></dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#2742f46432cfddb297c88300b3b93ebd">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div><p>
<a class="anchor" name="2d893fc8a09eedb145b89d56e7758c8b"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::isPrefixOf" ref="2d893fc8a09eedb145b89d56e7758c8b" args="(ContentName name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.protocol.ContentName.isPrefixOf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if this name is a prefix of another name - i.e. 
<p>
do all components in this name exist in the name being compared with. Note there do not need to be any more components in the name being compared with. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name being compared with. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9b1ef8aaf1b74a4b1304aa5a3f711775"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::isPrefixOf" ref="9b1ef8aaf1b74a4b1304aa5a3f711775" args="(ContentName name, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.protocol.ContentName.isPrefixOf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests if the first n components are a prefix of name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of components to check </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="491e988e4762b4809f4c9bfdac100d12"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::isPrefixOf" ref="491e988e4762b4809f4c9bfdac100d12" args="(ContentObject other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.protocol.ContentName.isPrefixOf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare our name to the name of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html" title="Represents a CCNx data packet.">ContentObject</a>. 
<p>
If our name is 1 component longer than the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html" title="Represents a CCNx data packet.">ContentObject</a> and no prefix count is set, our name might contain a digest. In that case, try matching the content to the last component as a digest.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="88711707916bda3afc72eb59251672d7"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::parse" ref="88711707916bda3afc72eb59251672d7" args="(String str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.parse           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a> <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses the canonical URI representation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_malformed_content_name_string_exception.html">MalformedContentNameStringException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a58ca758313d641e311b1b8ba49e1d22"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::contains" ref="a58ca758313d641e311b1b8ba49e1d22" args="(String str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.protocol.ContentName.contains           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws URISyntaxException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses the canonical URI representation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="346f11d9e671037e98e212463ee0a895"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::containsWhere" ref="346f11d9e671037e98e212463ee0a895" args="(String str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.protocol.ContentName.containsWhere           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws URISyntaxException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for a component. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Component to search for, encoded using URI encoding. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The index of the first component that matched. Starts at 0. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>URISyntaxException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c8eabead5de9feb55a5ebe877f89d811"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::whereLast" ref="c8eabead5de9feb55a5ebe877f89d811" args="(String str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.protocol.ContentName.whereLast           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws URISyntaxException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for a component, starting from the end. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Component to search for, encoded using URI encoding. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The index of the first component that matched. Starts at 0. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>URISyntaxException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba6333be47fd3239deb19e0ae0b3d91f"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::containsWhere" ref="ba6333be47fd3239deb19e0ae0b3d91f" args="(byte[] component)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.protocol.ContentName.containsWhere           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>component</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return component index of the first matching component if it exists. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>component</em>&nbsp;</td><td>Component to search for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 on failure, component index otherwise (starts at 0). </dd></dl>

</div>
</div><p>
<a class="anchor" name="f2ff1e775ada6d5236f97ad263b202f9"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::whereLast" ref="f2ff1e775ada6d5236f97ad263b202f9" args="(byte[] component)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.protocol.ContentName.whereLast           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>component</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return component index of the last matching component if it exists. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>component</em>&nbsp;</td><td>Component to search for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 on failure, component index otherwise (starts at 0). </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcd8206fc0efc153268d099a00c5f385"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::startsWith" ref="bcd8206fc0efc153268d099a00c5f385" args="(byte[] value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.protocol.ContentName.startsWith           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does a component of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html" title="ContentNames consist of a sequence of byte[] components which may not be assumed...">ContentName</a> startWith value? 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="ed516235f039003d4a2c537bfdc15661"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::startsWithWhere" ref="ed516235f039003d4a2c537bfdc15661" args="(byte[] value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.protocol.ContentName.startsWithWhere           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return component index of first component that starts with argument value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="a0e5688e740e866cb397bc04315c7c8b"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::cut" ref="a0e5688e740e866cb397bc04315c7c8b" args="(int componentCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.cut           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>componentCount</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the first componentNumber components of this name as a new name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>componentNumber</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="fef295d847bdff9f86d138eb6c4b1f0f"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::cut" ref="fef295d847bdff9f86d138eb6c4b1f0f" args="(byte[] component)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.cut           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>component</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Slice the name off right before the given component. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>component</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d496516ccc9e6ae69713c21f55d0d9d3"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::cut" ref="d496516ccc9e6ae69713c21f55d0d9d3" args="(String component)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.cut           </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>component</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws URISyntaxException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Slice the name off right before the given component. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>component</em>&nbsp;</td><td>In URI encoded form. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="69ffdeb5082a6b99c3c1c066977b349e"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::subname" ref="69ffdeb5082a6b99c3c1c066977b349e" args="(int start, int componentCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.subname           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>componentCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a subname of this name as a new name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>the starting component index (0-based) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>componentCount</em>&nbsp;</td><td>the number of components to include beginning with start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5bf8f640c9dbc90e822e64d3d9810bc5"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::postfix" ref="5bf8f640c9dbc90e822e64d3d9810bc5" args="(ContentName prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.protocol.ContentName.postfix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>prefix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the remainder of this name after the prefix, if the prefix is a prefix of this name. 
<p>
Otherwise return null. If the prefix is identical to this name, return the root (empty) name. 
</div>
</div><p>
<a class="anchor" name="cafaac1100675191a699b60d1d8fce3b"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::encode" ref="cafaac1100675191a699b60d1d8fce3b" args="(XMLEncoder encoder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.protocol.ContentName.encode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encoder.html">XMLEncoder</a>&nbsp;</td>
          <td class="paramname"> <em>encoder</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws ContentEncodingException <code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used by NetworkObject to encode the object to a network stream. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_x_m_l_encodable.html" title="Top-level interface implemented by objects that want to make use of our stream encoding...">org.ccnx.ccn.impl.encoding.XMLEncodable</a> </dd></dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#eb997279d10d18277cab484de7edf741">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div><p>
<a class="anchor" name="335255b177f49718b4643380c89083b9"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::validate" ref="335255b177f49718b4643380c89083b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.protocol.ContentName.validate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure all of the necessary fields are filled in prior to attempting to encode. 
<p>
All implementations of <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html#cafaac1100675191a699b60d1d8fce3b" title="Used by NetworkObject to encode the object to a network stream.">encode(XMLEncoder)</a> should call this for their classes prior to encoding. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if object is valid and can be encoded, false if there is a problem; for example mandatory fields are uninitialized </dd></dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#0cc2a6cf56f0853fa0ab1c514b65e6b6">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

</div>
</div><p>
<a class="anchor" name="e853328e7f894b9c21d9c60e24443d1b"></a><!-- doxytag: member="org::ccnx::ccn::protocol::ContentName::getElementLabel" ref="e853328e7f894b9c21d9c60e24443d1b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.protocol.ContentName.getElementLabel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow the encoder/decoder to retrieve the top-level element name programmatically. 
<p>
This allows subclasses to rename elements without changing their encoder/decoders. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the element label to use, as a key in a loaded encoding dictionary </dd></dl>

<p>Implements <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1encoding_1_1_generic_x_m_l_encodable.html#643e91ecff8b7ed820063e7537e23acd">org.ccnx.ccn.impl.encoding.GenericXMLEncodable</a>.</p>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapping_key_name.html#f370865a052d81892200b332a6f14a8c">org.ccnx.ccn.io.content.WrappingKeyName</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/protocol/ContentName.java</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Sep 14 12:44:31 2011 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
