<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Content-Centric Networking in Java: org.ccnx.ccn.io.content.KeyDirectory Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>io</b>.<b>content</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html">KeyDirectory</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.io.content.KeyDirectory Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::io::content::KeyDirectory" --><!-- doxytag: inherits="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList" -->A key directory holds a key (secret or private), distributed to entities (represented by public keys), by a set of key blocks each of which wrapping that key under different target keys.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for org.ccnx.ccn.io.content.KeyDirectory:</div>
<div class="dynsection">

<p><center><img src="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.png" usemap="#org.ccnx.ccn.io.content.KeyDirectory_map" border="0" alt=""></center>
<map name="org.ccnx.ccn.io.content.KeyDirectory_map">
<area href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" alt="org.ccnx.ccn.profiles.nameenum.EnumeratedNameList" shape="rect" coords="0,56,392,80">
<area href="interfaceorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_basic_name_enumerator_listener.html" alt="org.ccnx.ccn.profiles.nameenum.BasicNameEnumeratorListener" shape="rect" coords="0,0,392,24">
<area href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_principal_key_directory.html" alt="org.ccnx.ccn.profiles.security.access.group.PrincipalKeyDirectory" shape="rect" coords="0,168,392,192">
</map>
</div>

<p>
<a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#7d87cf8ec540c4531fdeb17f547baeb1">KeyDirectory</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> directoryName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory name should be versioned, else we pull the latest version; start enumeration.  <a href="#7d87cf8ec540c4531fdeb17f547baeb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a6254cf0a256aa254047e8e228db9db7">KeyDirectory</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> directoryName, boolean enumerate, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory name should be versioned, else we pull the latest version.  <a href="#a6254cf0a256aa254047e8e228db9db7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#1f5fb870d06ff2010db6cd029b688b14">hasResult</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclasses should override this <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1test.html" title="PD org.ccnx.ccn.test.">test</a> to answer true if waiters should break out of a waitForNoUpdatesOrResult loop.  <a href="#1f5fb870d06ff2010db6cd029b688b14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#ef127a673dc0acb891ea3123dfed3f77">getCopyOfWrappingKeyIDs</a> ()  throws ContentNotReadyException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a copy to avoid synchronization problems.  <a href="#ef127a673dc0acb891ea3123dfed3f77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#704b32238317892f2b8f09c806e8e4ab">getCopyOfOtherNames</a> ()  throws ContentNotReadyException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy to avoid synchronization problems.  <a href="#704b32238317892f2b8f09c806e8e4ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#ae5381a02cd880fae2e36e1cd3fab4f9">getWrappedKeyForKeyID</a> (byte[] keyID)  throws ContentDecodingException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key object corresponding to a public key specified by its digest.  <a href="#ae5381a02cd880fae2e36e1cd3fab4f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a3b7265afcf8e99f0c62f12555d56e43">getWrappedKeyNameForKeyID</a> (byte[] keyID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key name for a public key specified by its digest.  <a href="#a3b7265afcf8e99f0c62f12555d56e43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#1a964a9e10ebfebc72d62121d3cab52a">hasSupersededBlock</a> ()  throws ContentNotReadyException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for the existence of a superseded block.  <a href="#1a964a9e10ebfebc72d62121d3cab52a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7306964b8292661a65e800c6cb9554d6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getSupersededBlockName" ref="7306964b8292661a65e800c6cb9554d6" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getSupersededBlockName</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#aa2a1a1e05b49223a9c16cedbcb627ca">getSupersededWrappedKey</a> ()  throws ContentDecodingException, ContentNotReadyException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We have several choices for how to represent superseded and previous keys.  <a href="#aa2a1a1e05b49223a9c16cedbcb627ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#767ae095ec17bb5ce9ebda35883a0655">getWrappedKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> wrappedKeyName)  throws ContentDecodingException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key object corresponding to the specified wrapped key name.  <a href="#767ae095ec17bb5ce9ebda35883a0655"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#3b0e4c5e9345b924acc63e92d3e0e0ad">hasPreviousKeyBlock</a> ()  throws ContentNotReadyException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for the existence of a previous key block.  <a href="#3b0e4c5e9345b924acc63e92d3e0e0ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="38cfc7c00a4d75562c5d138b368c860e"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPreviousKeyBlockName" ref="38cfc7c00a4d75562c5d138b368c860e" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPreviousKeyBlockName</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link.html">Link</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#613294cc3bb3fc069d80837975ff47c2">getPreviousKey</a> (long timeout)  throws ContentNotReadyException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a link to the previous key.  <a href="#613294cc3bb3fc069d80837975ff47c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#1cfafe64a2b2f90665176d24b4e9e34e">hasPrivateKeyBlock</a> ()  throws ContentNotReadyException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We store a private key as a single block wrapped under a nonce key, which is then wrapped under the public keys of various principals.  <a href="#1cfafe64a2b2f90665176d24b4e9e34e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="562f7a47f1c63157889d8c9ddf07acec"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPrivateKeyBlockName" ref="562f7a47f1c63157889d8c9ddf07acec" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPrivateKeyBlockName</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#7e88b2b7596265d2e52b85e308b85c4b">getUnwrappedKey</a> (byte[] expectedKeyID)  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwrap and return the key wrapped in a wrapping key specified by its digest.  <a href="#7e88b2b7596265d2e52b85e308b85c4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#45969d2265e2d99ef0acb495a510acb8">isPrivateKeyInCache</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PrivateKey&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#1b14e09c4dd879ab780e86fe4b120906">getPrivateKey</a> ()  throws AccessDeniedException, InvalidKeyException,  	ContentNotReadyException, ContentGoneException, ContentDecodingException,  	IOException, NoSuchAlgorithmException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the private key stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>.  <a href="#1b14e09c4dd879ab780e86fe4b120906"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#d4f2cd07ceba295883bf35dd3257714d">addWrappedKeyBlock</a> (Key secretKeyToWrap, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> publicKeyName, PublicKey publicKey)  throws ContentEncodingException, IOException, InvalidKeyException, VersionMissingException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a wrapped key block to the repository.  <a href="#d4f2cd07ceba295883bf35dd3257714d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#19345df2049e38c420e2e015ab871fe6">addPrivateKeyBlock</a> (PrivateKey privateKey, Key privateKeyWrappingKey)  throws ContentEncodingException, IOException, InvalidKeyException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a private key block to the repository.  <a href="#19345df2049e38c420e2e015ab871fe6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#dfbaeb301c104c94587b711ee581faa6">addSupersededByBlock</a> (Key oldPrivateKeyWrappingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key newPrivateKeyWrappingKey)  throws InvalidKeyException, ContentEncodingException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a superseded-by block to our key directory.  <a href="#dfbaeb301c104c94587b711ee581faa6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#f1cc5eff557c2d8ab7b2d8bae03d7c09">addPreviousKeyLink</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> previousKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_i_d.html">PublisherID</a> previousKeyPublisher)  throws ContentEncodingException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a link to a previous key to the repository.  <a href="#f1cc5eff557c2d8ab7b2d8bae03d7c09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#3befc109edc280fbad489697a06281b2">addPreviousKeyBlock</a> (Key oldPrivateKeyWrappingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> supersedingKeyName, Key newPrivateKeyWrappingKey)  throws InvalidKeyException, ContentEncodingException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a previous key block to the repository.  <a href="#3befc109edc280fbad489697a06281b2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98db97d3f456e934538c78a19b0977f1"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getSupersededBlockNameForKey" ref="98db97d3f456e934538c78a19b0977f1" args="(ContentName versionedKeyName)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getSupersededBlockNameForKey</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> versionedKeyName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05a5cba8cf1cbceacf4e89c86fe74cae"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPreviousKeyBlockName" ref="05a5cba8cf1cbceacf4e89c86fe74cae" args="(ContentName keyDirectoryName)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPreviousKeyBlockName</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyDirectoryName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#1b5bd9c8af2c2fdedf00d1f63a915bf3">addSupersededByBlock</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> oldKeyVersionedNameToAddBlockTo, Key oldKeyToBeSuperseded, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key supersedingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws ContentEncodingException, IOException, InvalidKeyException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a superseded-by block to another node key, where we may have only its name, not its enumeration.  <a href="#1b5bd9c8af2c2fdedf00d1f63a915bf3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6dc57a825060629184f4552342d67b83"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::SUPERSEDED_MARKER" ref="6dc57a825060629184f4552342d67b83" args="" -->
static final byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>SUPERSEDED_MARKER</b> = &quot;SupersededBy&quot;.getBytes()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5983805bc4e6fcc66ea89b585941fc0d"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::PREVIOUS_KEY_NAME" ref="5983805bc4e6fcc66ea89b585941fc0d" args="" -->
static final byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>PREVIOUS_KEY_NAME</b> = &quot;PreviousKey&quot;.getBytes()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd6797e92a335c94116ee45107ea4926"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::GROUP_PUBLIC_KEY_NAME" ref="dd6797e92a335c94116ee45107ea4926" args="" -->
static final byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>GROUP_PUBLIC_KEY_NAME</b> = &quot;Key&quot;.getBytes()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6b6734aef04ba81cd3735c8552ab763f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::GROUP_PRIVATE_KEY_NAME" ref="6b6734aef04ba81cd3735c8552ab763f" args="" -->
static final byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>GROUP_PRIVATE_KEY_NAME</b> = &quot;PrivateKey&quot;.getBytes()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#3db09cbfc4af2b2daed36840f3abbcc8">initialize</a> (boolean startEnumerating)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We don't start enumerating until we get here.  <a href="#3db09cbfc4af2b2daed36840f3abbcc8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca5811be11ad57f76e64f1e2740b82b9"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::processNewChildren" ref="ca5811be11ad57f76e64f1e2740b82b9" args="(SortedSet&lt; ContentName &gt; newChildren)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#ca5811be11ad57f76e64f1e2740b82b9">processNewChildren</a> (SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt; newChildren)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called each time new data comes in, gets to parse it and load processed arrays. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b5debf7ea9649c53dd298b64ad254a9"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::processNewChild" ref="0b5debf7ea9649c53dd298b64ad254a9" args="(byte[] wkChildName)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>processNewChild</b> (byte[] wkChildName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#70631f2cc0ed483acb277c2cbe07aa34">getPrivateKeyObject</a> ()  throws ContentGoneException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the private key object, if one exists as a wrapped key object.  <a href="#70631f2cc0ed483acb277c2cbe07aa34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c01dbd68c16abda0986b8354e2bfd1dd"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::findUnwrappedKey" ref="c01dbd68c16abda0986b8354e2bfd1dd" args="(byte[] expectedKeyID)" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>findUnwrappedKey</b> (byte[] expectedKeyID)  throws IOException, 			ContentNotReadyException, InvalidKeyException, 			ContentDecodingException, NoSuchAlgorithmException </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#0e072833bc839bd2a339ee4f8c6197b0">unwrapKeyViaCache</a> (byte[] keyIDOfCachedKeytoUse)  throws ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast path -- once we have an idea which of our keys will unwrap this key, get it.  <a href="#0e072833bc839bd2a339ee4f8c6197b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b4509430b71889328c9ea94cf9c893b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::unwrapKeyViaCache" ref="0b4509430b71889328c9ea94cf9c893b" args="()" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>unwrapKeyViaCache</b> ()  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f6f6f4408f669098b9578f06c0bb393"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::unwrapKeyViaSupersededKey" ref="3f6f6f4408f669098b9578f06c0bb393" args="()" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>unwrapKeyViaSupersededKey</b> ()  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2809f4c664aaf8afe75712d7622e6d43"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::factory" ref="2809f4c664aaf8afe75712d7622e6d43" args="(ContentName name)" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html">KeyDirectory</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>factory</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name)  throws IOException </td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="24c9e81016f14c05aafcd9a3e91f1712"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_handle" ref="24c9e81016f14c05aafcd9a3e91f1712" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_handle</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e70c4423ed6d1b5bd93bc210dc6e2977"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::cacheHit" ref="e70c4423ed6d1b5bd93bc210dc6e2977" args="" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>cacheHit</b></td></tr>

<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2902506c54529831b36ea2ddba887926"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::byteArrayComparator" ref="2902506c54529831b36ea2ddba887926" args="" -->
static final Comparator&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>byteArrayComparator</b> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1support_1_1_byte_array_compare.html">ByteArrayCompare</a>()</td></tr>

<tr><td colspan="2"><br><h2>Package Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e8c722591969672230f9a65dd07dc13"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_keyIDs" ref="4e8c722591969672230f9a65dd07dc13" args="" -->
TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#4e8c722591969672230f9a65dd07dc13">_keyIDs</a> = new TreeSet&lt;byte []&gt;(byteArrayComparator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The set _keyIDs contains the digests of the (public) wrapping keys of the wrapped key objects stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34376976ad6f06c49fba0236fa361e9d"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_keyIDLock" ref="34376976ad6f06c49fba0236fa361e9d" args="" -->
final ReadWriteLock&nbsp;</td><td class="memItemRight" valign="bottom"><b>_keyIDLock</b> = new ReentrantReadWriteLock()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21116d7c77b708ac60667a4bcb27fdb6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_otherNames" ref="21116d7c77b708ac60667a4bcb27fdb6" args="" -->
TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#21116d7c77b708ac60667a4bcb27fdb6">_otherNames</a> = new TreeSet&lt;byte []&gt;(byteArrayComparator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The set _otherNames records the presence of superseded keys, previous keys, group private keys, etc. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8389f7b43646b5e4075e70aa1948135f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_otherNamesLock" ref="8389f7b43646b5e4075e70aa1948135f" args="" -->
final ReadWriteLock&nbsp;</td><td class="memItemRight" valign="bottom"><b>_otherNamesLock</b> = new ReentrantReadWriteLock()</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>NoPrivateKeyException</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A key directory holds a key (secret or private), distributed to entities (represented by public keys), by a set of key blocks each of which wrapping that key under different target keys. 
<p>
If the key to be distributed is a private key, it is first wrapped under a nonce key, and that nonce key is stored encrypted under the keys of the receiving entitites.<p>
Essentially a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a> is a software wrapper for managing a set of content stored in CCNx (writing and reading portions of that content); that content consists of a set of key blocks used to give one key to a number of target entities.<p>
Key blocks are implemented as a set of wrapped key objects all stored in one directory. Wrapped key objects are typically short and only need one segment. The directory the keys are stored in is prefixed by a version, to allow the contents to evolve. In addition some potential supporting information pointing to previous or subsequent versions of this key is kept. A particular wrapped key entry's name would look like:<p>
<pre>&lt;keyname&gt;/version/xxx/s0</pre> <br>
Where xxx is the identifier of the wrapped key.<p>
Our model is that higher-level function may use this interface to try many ways to get a given key. Some will work (access is allowed), some may not -- the latter does not mean that the principal doesn't have access, just that the principal doesn't have access by this route. So for the moment, we return null when we don't conclusively know that this principal doesn't have access to this data somehow, rather than throwing AccessDeniedException. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="7d87cf8ec540c4531fdeb17f547baeb1"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::KeyDirectory" ref="7d87cf8ec540c4531fdeb17f547baeb1" args="(ContentName directoryName, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.content.KeyDirectory.KeyDirectory           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>directoryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Directory name should be versioned, else we pull the latest version; start enumeration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>manager</em>&nbsp;</td><td>the access control manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>directoryName</em>&nbsp;</td><td>the root of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a6254cf0a256aa254047e8e228db9db7"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::KeyDirectory" ref="a6254cf0a256aa254047e8e228db9db7" args="(ContentName directoryName, boolean enumerate, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.content.KeyDirectory.KeyDirectory           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>directoryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>enumerate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Directory name should be versioned, else we pull the latest version. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directoryName</em>&nbsp;</td><td>the root of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3db09cbfc4af2b2daed36840f3abbcc8"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::initialize" ref="3db09cbfc4af2b2daed36840f3abbcc8" args="(boolean startEnumerating)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.initialize           </td>
          <td>(</td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>startEnumerating</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We don't start enumerating until we get here. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_principal_key_directory.html#532c3e6bcbbbbb74604380aab0ec12b2">org.ccnx.ccn.profiles.security.access.group.PrincipalKeyDirectory</a>.</p>

</div>
</div><p>
<a class="anchor" name="1f5fb870d06ff2010db6cd029b688b14"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::hasResult" ref="1f5fb870d06ff2010db6cd029b688b14" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.hasResult           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subclasses should override this <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1test.html" title="PD org.ccnx.ccn.test.">test</a> to answer true if waiters should break out of a waitForNoUpdatesOrResult loop. 
<p>
Note that results must be cleared manually using clearResult. Default behavior always returns false. Subclasses probably want to set a variable in processNewChildren that will be read here. 
<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#f593f0d16a23fc8b8488487e6fce7c81">org.ccnx.ccn.profiles.nameenum.EnumeratedNameList</a>.</p>

</div>
</div><p>
<a class="anchor" name="ef127a673dc0acb891ea3123dfed3f77"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getCopyOfWrappingKeyIDs" ref="ef127a673dc0acb891ea3123dfed3f77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreeSet&lt;byte []&gt; org.ccnx.ccn.io.content.KeyDirectory.getCopyOfWrappingKeyIDs           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a copy to avoid synchronization problems. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="704b32238317892f2b8f09c806e8e4ab"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getCopyOfOtherNames" ref="704b32238317892f2b8f09c806e8e4ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreeSet&lt;byte []&gt; org.ccnx.ccn.io.content.KeyDirectory.getCopyOfOtherNames           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a copy to avoid synchronization problems. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ae5381a02cd880fae2e36e1cd3fab4f9"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getWrappedKeyForKeyID" ref="ae5381a02cd880fae2e36e1cd3fab4f9" args="(byte[] keyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.getWrappedKeyForKeyID           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws ContentDecodingException, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the wrapped key object corresponding to a public key specified by its digest. 
<p>
Up to caller to decide when this is reasonable to call; should call available() on result. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyID</em>&nbsp;</td><td>the digest of the specified public key. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the corresponding wrapped key object. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a3b7265afcf8e99f0c62f12555d56e43"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getWrappedKeyNameForKeyID" ref="a3b7265afcf8e99f0c62f12555d56e43" args="(byte[] keyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.io.content.KeyDirectory.getWrappedKeyNameForKeyID           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the wrapped key name for a public key specified by its digest. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyID</em>&nbsp;</td><td>the digest of the public key. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the corresponding wrapped key name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a964a9e10ebfebc72d62121d3cab52a"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::hasSupersededBlock" ref="1a964a9e10ebfebc72d62121d3cab52a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.hasSupersededBlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for the existence of a superseded block. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="aa2a1a1e05b49223a9c16cedbcb627ca"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getSupersededWrappedKey" ref="aa2a1a1e05b49223a9c16cedbcb627ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.getSupersededWrappedKey           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws ContentDecodingException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We have several choices for how to represent superseded and previous keys. 
<p>
Ignoring for now the case where we might have to have more than one per key directory (e.g. if we represent removal of several interposed ACLs), we could have the wrapped key block stored in the superseded block location, and the previous key block be a link, or the previous key block be a wrapped key and the superseded location be a link. Or we could store wrapped key blocks in both places. Because the wrapped key blocks can contain the name of the key that wrapped them (but not the key being wrapped), they are in essence a pointer forward to the replacing key. So, the superseded block, if it contains a wrapped key, is both a key and a link. If the block was stored at the previous key, it would not be both a key and a link, as its wrapping key is indicated by where it is. So it should indeed be a link -- except in the case of an interposed ACL, where there is nothing to link to; and it instead stores a wrapped key block containing the effective node key that was the previous key. This method checks for the existence of a superseded block. <dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="767ae095ec17bb5ce9ebda35883a0655"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getWrappedKey" ref="767ae095ec17bb5ce9ebda35883a0655" args="(ContentName wrappedKeyName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.getWrappedKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>wrappedKeyName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws ContentDecodingException, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the wrapped key object corresponding to the specified wrapped key name. 
<p>
We know there is only one version of this object, so avoid getLatestVersion. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrappedKeyName</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3b0e4c5e9345b924acc63e92d3e0e0ad"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::hasPreviousKeyBlock" ref="3b0e4c5e9345b924acc63e92d3e0e0ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.hasPreviousKeyBlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for the existence of a previous key block. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="613294cc3bb3fc069d80837975ff47c2"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPreviousKey" ref="613294cc3bb3fc069d80837975ff47c2" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link.html">Link</a> org.ccnx.ccn.io.content.KeyDirectory.getPreviousKey           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a link to the previous key. 
<p>
Previous key might be a link, if we're a simple newer version, or it might be a wrapped key, if we're an interposed node key. DKS TODO <dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1cfafe64a2b2f90665176d24b4e9e34e"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::hasPrivateKeyBlock" ref="1cfafe64a2b2f90665176d24b4e9e34e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.hasPrivateKeyBlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We store a private key as a single block wrapped under a nonce key, which is then wrapped under the public keys of various principals. 
<p>
The <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a> structure would allow us to do this (wrap private in public) in a single object, with an inline nonce key, but this option is more efficient. Checks for the existence of a private key block <dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="70631f2cc0ed483acb277c2cbe07aa34"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPrivateKeyObject" ref="70631f2cc0ed483acb277c2cbe07aa34" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.getPrivateKeyObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the private key object, if one exists as a wrapped key object. 
<p>
Does not check to see if we have a private key block; simply sends a request for it (saves the requirement to do enumeration). Callers should check available() on the result to see if we actually got one. In general, callers will know whether one should exist or not. hasPrivateKeyBlock can be used to <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1test.html" title="PD org.ccnx.ccn.test.">test</a> (after enumeration) whether one exists if you don't know. <dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html" title="Informative subclass of IOException to be thrown when content is expected, but GONE...">ContentGoneException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7e88b2b7596265d2e52b85e308b85c4b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getUnwrappedKey" ref="7e88b2b7596265d2e52b85e308b85c4b" args="(byte[] expectedKeyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key org.ccnx.ccn.io.content.KeyDirectory.getUnwrappedKey           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>expectedKeyID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unwrap and return the key wrapped in a wrapping key specified by its digest. 
<p>
Find a copy of the key block in this directory that we can unwrap (either the private key wrapping key block or a wrapped raw symmetric key). Chase superseding keys if we have to. This mechanism should be generic, and should work for node keys as well as private key wrapping keys in directories following this structure. <dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e072833bc839bd2a339ee4f8c6197b0"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::unwrapKeyViaCache" ref="0e072833bc839bd2a339ee4f8c6197b0" args="(byte[] keyIDOfCachedKeytoUse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key org.ccnx.ccn.io.content.KeyDirectory.unwrapKeyViaCache           </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyIDOfCachedKeytoUse</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fast path -- once we have an idea which of our keys will unwrap this key, get it. 
<p>
Can be called after enumeration, or if we have a guess of what key to use. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyIDOfCachedKeytoUse</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="45969d2265e2d99ef0acb495a510acb8"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::isPrivateKeyInCache" ref="45969d2265e2d99ef0acb495a510acb8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.isPrivateKeyInCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the private key is in the secure key cache. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b14e09c4dd879ab780e86fe4b120906"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPrivateKey" ref="1b14e09c4dd879ab780e86fe4b120906" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PrivateKey org.ccnx.ccn.io.content.KeyDirectory.getPrivateKey           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1_access_denied_exception.html">AccessDeniedException</a>, InvalidKeyException,  	<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, ContentDecodingException,  	IOException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the private key stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. 
<p>
The private key is wrapped in a wrapping key, which is itself wrapped. So the unwrapping proceeds in two steps. First, we unwrap the wrapping key for the private key. Then, we unwrap the private key itself. Relies on the caller, who presumably knows the public key, to add the result to the cache. <dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AccessDeniedException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html" title="Informative subclass of IOException to be thrown when content is expected, but GONE...">ContentGoneException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d4f2cd07ceba295883bf35dd3257714d"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addWrappedKeyBlock" ref="d4f2cd07ceba295883bf35dd3257714d" args="(Key secretKeyToWrap, ContentName publicKeyName, PublicKey publicKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.addWrappedKeyBlock           </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>secretKeyToWrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>publicKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublicKey&nbsp;</td>
          <td class="paramname"> <em>publicKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws ContentEncodingException, IOException, InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_version_missing_exception.html">VersionMissingException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a wrapped key block to the repository. 
<p>
Eventually aggregate signing and repo stream operations at the very least across writing paired objects and links, preferably across larger swaths of data. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>secretKeyToWrap</em>&nbsp;</td><td>either a node key, a data key, or a private key wrapping key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publicKeyName</em>&nbsp;</td><td>the name of the public key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publicKey</em>&nbsp;</td><td>the public key. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionMissingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionMissingException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_principal_key_directory.html#f2ff6d464ba2cf98c8c7d6c564dadff7">org.ccnx.ccn.profiles.security.access.group.PrincipalKeyDirectory</a>.</p>

</div>
</div><p>
<a class="anchor" name="19345df2049e38c420e2e015ab871fe6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addPrivateKeyBlock" ref="19345df2049e38c420e2e015ab871fe6" args="(PrivateKey privateKey, Key privateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.addPrivateKeyBlock           </td>
          <td>(</td>
          <td class="paramtype">PrivateKey&nbsp;</td>
          <td class="paramname"> <em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>privateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws ContentEncodingException, IOException, InvalidKeyException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a private key block to the repository. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>privateKey</em>&nbsp;</td><td>the private key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>privateKeyWrappingKey</em>&nbsp;</td><td>the wrapping key used to wrap the private key. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dfbaeb301c104c94587b711ee581faa6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addSupersededByBlock" ref="dfbaeb301c104c94587b711ee581faa6" args="(Key oldPrivateKeyWrappingKey, ContentName storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key newPrivateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.addSupersededByBlock           </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldPrivateKeyWrappingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>newPrivateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, ContentEncodingException, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a superseded-by block to our key directory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supersedingKeyName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1b5bd9c8af2c2fdedf00d1f63a915bf3"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addSupersededByBlock" ref="1b5bd9c8af2c2fdedf00d1f63a915bf3" args="(ContentName oldKeyVersionedNameToAddBlockTo, Key oldKeyToBeSuperseded, ContentName storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key supersedingKey, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void org.ccnx.ccn.io.content.KeyDirectory.addSupersededByBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>oldKeyVersionedNameToAddBlockTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldKeyToBeSuperseded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>supersedingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws ContentEncodingException, IOException, InvalidKeyException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a superseded-by block to another node key, where we may have only its name, not its enumeration. 
<p>
Use as a static method to add our own superseded-by blocks as well. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f1cc5eff557c2d8ab7b2d8bae03d7c09"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addPreviousKeyLink" ref="f1cc5eff557c2d8ab7b2d8bae03d7c09" args="(ContentName previousKey, PublisherID previousKeyPublisher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.addPreviousKeyLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>previousKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_i_d.html">PublisherID</a>&nbsp;</td>
          <td class="paramname"> <em>previousKeyPublisher</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws ContentEncodingException, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a link to a previous key to the repository. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>previousKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>previousKeyPublisher</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3befc109edc280fbad489697a06281b2"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addPreviousKeyBlock" ref="3befc109edc280fbad489697a06281b2" args="(Key oldPrivateKeyWrappingKey, ContentName supersedingKeyName, Key newPrivateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.addPreviousKeyBlock           </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldPrivateKeyWrappingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>supersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>newPrivateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, ContentEncodingException, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a previous key block to the repository. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supersedingKeyName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/io/content/KeyDirectory.java</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Sep 14 12:44:29 2011 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
