<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Content-Centric Networking in Java: org.ccnx.ccn.impl.CCNSegmenter Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1impl.html">impl</a>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.impl.CCNSegmenter Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::impl::CCNSegmenter" -->Combines segmentation, signing and encryption.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#6270483ef281895470732b058c67cb68">CCNSegmenter</a> ()  throws ConfigurationException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a segmenter with default (Merkle hash tree) bulk signing behavior, making a new handle for it to use.  <a href="#6270483ef281895470732b058c67cb68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#897605a8a0b8362cdab1148822d6f824">CCNSegmenter</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a segmenter with default (Merkle hash tree) bulk signing behavior.  <a href="#897605a8a0b8362cdab1148822d6f824"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#7f4de398987fee9331bb1ef65c4ebc59">CCNSegmenter</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a segmenter with default (Merkle hash tree) bulk signing behavior.  <a href="#7f4de398987fee9331bb1ef65c4ebc59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#67d2dd38c5b73daf51d3d68585dca62f">CCNSegmenter</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl, <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_aggregated_signer.html">CCNAggregatedSigner</a> signer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a segmenter, specifying the signing behavior to use.  <a href="#67d2dd38c5b73daf51d3d68585dca62f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ab255206910eaf5c8dfa8ad9b687f224"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getLibrary" ref="ab255206910eaf5c8dfa8ad9b687f224" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getLibrary</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3fb6114fc0f884661bc0ba6b91d0873"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getFlowControl" ref="c3fb6114fc0f884661bc0ba6b91d0873" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getFlowControl</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#c8f58ebde44d814fab179c03b6a4cc28">getFirstSegment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first segment.  <a href="#c8f58ebde44d814fab179c03b6a4cc28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#06cfa8f913ab06e33ada929528cc65d4">setBlockSize</a> (int blockSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the segmentation block size to use.  <a href="#06cfa8f913ab06e33ada929528cc65d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#4f57d387423dfa4d1503e6a53e03068e">getBlockSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current block size.  <a href="#4f57d387423dfa4d1503e6a53e03068e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7bbd8b7bab8d8c1ffab28588749e6807"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::useByteCountSequenceNumbers" ref="7bbd8b7bab8d8c1ffab28588749e6807" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>useByteCountSequenceNumbers</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b998a96711cbd40e57fa022cc22bcd9b"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::useFixedIncrementSequenceNumbers" ref="b998a96711cbd40e57fa022cc22bcd9b" args="(int increment)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>useFixedIncrementSequenceNumbers</b> (int increment)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7ebce6a81ea68f709564ec21fcc3eead"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::useScaledByteCountSequenceNumbers" ref="7ebce6a81ea68f709564ec21fcc3eead" args="(int scale)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>useScaledByteCountSequenceNumbers</b> (int scale)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a934f0f48433dbb671bbebe1c137983e"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setSequenceType" ref="a934f0f48433dbb671bbebe1c137983e" args="(SegmentNumberType seqType)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setSequenceType</b> (SegmentNumberType seqType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#eef4920f19ba49caf9e3bd4a6952f8fe">setBlockIncrement</a> (int blockIncrement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the increment between block numbers.  <a href="#eef4920f19ba49caf9e3bd4a6952f8fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#3a4a8bfb37ee330526da89338506a966">getBlockIncrement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the increment between block numbers.  <a href="#3a4a8bfb37ee330526da89338506a966"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="49b31e60d5f3a8e5543f3a30ea00b5d4"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setByteScale" ref="49b31e60d5f3a8e5543f3a30ea00b5d4" args="(int byteScale)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setByteScale</b> (int byteScale)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8b23e43d491bd75522e7ec83e58021d"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getByteScale" ref="e8b23e43d491bd75522e7ec83e58021d" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>getByteScale</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#6c5b218290df2c29a2ea532d2fb4e9e7">put</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, byte[] content, int offset, int length, boolean lastSegments, SignedInfo.ContentType type, Integer freshnessSeconds, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts a complete data item, segmenting it if necessary.  <a href="#6c5b218290df2c29a2ea532d2fb4e9e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#408b24e3d72e569510e8544692af9cc4">fragmentedPut</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, byte[] content, int offset, int length, Long finalSegmentIndex, SignedInfo.ContentType type, Integer freshnessSeconds, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException,  	IOException, InvalidAlgorithmParameterException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segments content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network.  <a href="#408b24e3d72e569510e8544692af9cc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#027eca3398093134eba0f4af87659022">fragmentedPut</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, long baseSegmentNumber, byte[] content, int offset, int length, int blockWidth, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> timestamp, Integer freshnessSeconds, Long finalSegmentIndex, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException,  			SignatureException, IOException,  			InvalidAlgorithmParameterException, NoSuchAlgorithmException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segments content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network.  <a href="#027eca3398093134eba0f4af87659022"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#552e7a88a116e72a7bdb1f92c0d1950f">fragmentedPut</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, long baseSegmentNumber, byte contentBlocks[][], int blockCount, int firstBlockIndex, int lastBlockLength, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> timestamp, Integer freshnessSeconds, Long finalSegmentIndex, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, SignatureException,  			NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes pre-segmented content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network.  <a href="#552e7a88a116e72a7bdb1f92c0d1950f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#e9230fc0c4e7270d80bc92a88a55dc08">putFragment</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, long segmentNumber, byte[] content, int offset, int length, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> timestamp, Integer freshnessSeconds, Long finalSegmentIndex, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, SignatureException,  			NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts a single block of content of arbitrary length using a segment naming convention.  <a href="#e9230fc0c4e7270d80bc92a88a55dc08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#2ad60cb766d3419a5e1e16483f2a36c2">nextSegmentIndex</a> (long lastSegmentNumber, long lastSegmentLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment segment number according to the numbering profile in force.  <a href="#2ad60cb766d3419a5e1e16483f2a36c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#42cece4ed08a698e7fa26eb74d2a80e0">lastSegmentIndex</a> (long currentSegmentNumber, long bytesIntervening, int blocksRemaining)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the index of the last block of a set of segments, according to the numbering profile.  <a href="#42cece4ed08a698e7fa26eb74d2a80e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#07015cd40f6afaa8818baf63b4537342">setTimeout</a> (int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the timeout on the contained flow controller.  <a href="#07015cd40f6afaa8818baf63b4537342"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#fa5cd186cdde6d267642c82fe318b735">outputLength</a> (int inputLength, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How many content bytes will it take to represent content of length length, including any padding incurred by encryption?  <a href="#fa5cd186cdde6d267642c82fe318b735"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#d88c86629cd8e761c03d76f25757eef3">getBlockSegmenter</a> (int blockSize, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method to create a standard segmenter that generates blocks of fixed length in bytes.  <a href="#d88c86629cd8e761c03d76f25757eef3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#4b3385e178bb310da868068c4acf89bc">getScaledByteCountSegmenter</a> (int scale, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method to create a standard segmenter that generates blocks of variable length in bytes, whose segment numbers are scaled by a fixed increment.  <a href="#4b3385e178bb310da868068c4acf89bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#1570a8c5b3a3db4505a88e107c654f26">getByteCountSegmenter</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method to create a standard segmenter that generates blocks of variable length in bytes, whose segment numbers are scaled by a fixed increment.  <a href="#1570a8c5b3a3db4505a88e107c654f26"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5009996e8b65087c9c2f33980d2d9546"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::HOLD_COUNT" ref="5009996e8b65087c9c2f33980d2d9546" args="" -->
static final int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#5009996e8b65087c9c2f33980d2d9546">HOLD_COUNT</a> = 128</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of content objects we keep around prior to signing and outputting to the flow controller Note that the flow controller also uses this value to determine its default high water mark. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0028330031e1300dd5da0eede77c1708"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::PROP_BLOCK_SIZE" ref="0028330031e1300dd5da0eede77c1708" args="" -->
static final String&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROP_BLOCK_SIZE</b> = &quot;ccn.lib.blocksize&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fcc0a3728721a6e364066a9b31d98231"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::LAST_SEGMENT" ref="fcc0a3728721a6e364066a9b31d98231" args="" -->
static final long&nbsp;</td><td class="memItemRight" valign="bottom"><b>LAST_SEGMENT</b> = Long.valueOf(-1)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e894066e42c4e1ead59a881af40552c"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::initializeBlockSize" ref="7e894066e42c4e1ead59a881af40552c" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>initializeBlockSize</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#06f2c591b18d93fdf2e36e1171b97f56">outputCurrentBlocks</a> (PrivateKey signingKey)  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sign and output all outstanding blocks to the flow controller.  <a href="#06f2c591b18d93fdf2e36e1171b97f56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#cfa807b1bbd0ac7ecf81e759b5cbb930">buildBlocks</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> rootName, long baseSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_signed_info.html">SignedInfo</a> signedInfo, byte[] content, int offset, int length, int blockWidth, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, PrivateKey signingKey, boolean finalFlush)  throws InvalidKeyException, InvalidAlgorithmParameterException, IOException, SignatureException, NoSuchAlgorithmException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper method to build ContentObjects for segments out of a contiguous buffer.  <a href="#cfa807b1bbd0ac7ecf81e759b5cbb930"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#04f5e2309a3ad4437350d374367fa0d8">newBlock</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> rootName, long segmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_signed_info.html">SignedInfo</a> signedInfo, byte contentBlock[], int offset, int blockLength, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, InvalidAlgorithmParameterException, ContentEncodingException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a ContentObject, encrypt it if requested, and add it to the list of ContentObjects awaiting signing and output to the flow controller.  <a href="#04f5e2309a3ad4437350d374367fa0d8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c8e5a09d9edc5bd1c874f5d3adf0b852"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_blockSize" ref="c8e5a09d9edc5bd1c874f5d3adf0b852" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>_blockSize</b> = <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#47ec5bad88f59ebc5be6b33a40bcd228">SegmentationProfile.DEFAULT_BLOCKSIZE</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67778a8f57d33490457d616a2328ae24"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_blockIncrement" ref="67778a8f57d33490457d616a2328ae24" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>_blockIncrement</b> = SegmentationProfile.DEFAULT_INCREMENT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b36416d37ca8f6de5e55f3318fddac3"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_byteScale" ref="3b36416d37ca8f6de5e55f3318fddac3" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>_byteScale</b> = SegmentationProfile.DEFAULT_SCALE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2fa6fd11d07658866383bf98a0d5416"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_sequenceType" ref="d2fa6fd11d07658866383bf98a0d5416" args="" -->
SegmentNumberType&nbsp;</td><td class="memItemRight" valign="bottom"><b>_sequenceType</b> = SegmentNumberType.SEGMENT_FIXED_INCREMENT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc62065c3cbdba813ab87046d44ab870"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_blocks" ref="bc62065c3cbdba813ab87046d44ab870" args="" -->
ArrayList&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>_blocks</b> = new ArrayList&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&gt;(<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#5009996e8b65087c9c2f33980d2d9546">HOLD_COUNT</a> + 1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d18096dcd663bd23feae6d12e27d6a22"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_handle" ref="d18096dcd663bd23feae6d12e27d6a22" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_handle</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a8edd27662c5bf6dc879c917309e0c7"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_flowControl" ref="6a8edd27662c5bf6dc879c917309e0c7" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#6a8edd27662c5bf6dc879c917309e0c7">_flowControl</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eventually may not contain this; callers may access it exogenously. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_aggregated_signer.html">CCNAggregatedSigner</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#0bdb3b5d7333606709c78200478a510c">_bulkSigner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle multi-block amortized signing.  <a href="#0bdb3b5d7333606709c78200478a510c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0cfa70fd2b9f41c2e813b614e335a34a"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_firstSegment" ref="0cfa70fd2b9f41c2e813b614e335a34a" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#0cfa70fd2b9f41c2e813b614e335a34a">_firstSegment</a> = null</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first segment, useful for obtaining starting segment number and digest to characterize set of segmented content. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Combines segmentation, signing and encryption. 
<p>
This is used to prepare data for writing out to ccnd. The intent is to provide a user-friendly, efficient, minimum-copy interface, with some <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1impl_1_1support.html" title="PD org.ccnx.ccn.impl.support.">support</a> for extensibility.<p>
<ul>
<li>
Segmentation is the division of a large piece of content into multiple smaller content objects. A segment component is appended to the content name to distinguish different segments. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html" title="We speak in terms of segments, not fragments, as this profile also encompasses packet-oriented...">org.ccnx.ccn.profiles.SegmentationProfile</a></dd></dl>
This class currently supports a range of quite complex segmentation options. At this point, only a subset of these are supported by the higher level org.ccnx.ccn.io interfaces.<p>
Contiguous blocks (fixed or variable size), or sparse blocks, e.g. at various time offsets. Configurations set the numbering scheme. The two interfaces are either contiguous writes, or (for the sparse case), writes of individual segments specified by offset (can be multi-buffered, as may be multiple KB).<p>
Simplest way to handle might be to expect contiguous blocks (either increments or byte count) and remember what we last wrote, so next call gets next value. Clients writing sparse blocks (only byte count or scaled byte count makes sense for this) can override by setting counter on a call.<p>
</li>
<li>
Signing Control -- per ContentObject signing with a choice of signature algorithm, or amortized signing. The default is Merkle Hash Tree based amortization, later there will be other options. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_merkle_tree_signer.html" title="A CCNAggregatedSigner that builds a Merkle hash tree over a set of blocks and signs...">org.ccnx.ccn.impl.security.crypto.CCNMerkleTreeSigner</a></dd></dl>
</li>
<li>
Stock low-level encryption. -- Given a key K, an IV, and a chosen encryption algorithm segment content so as to meet a desired net data length with potential block expansion, and encrypt.<p>
For this, we use the standard Java encryption mechanisms, augmented by alternative providers (e.g. BouncyCastle for AES-CTR). We just need a Cipher, a SecretKeySpec, and an IvParameterSpec holding the relevant key data.<p>
For block ciphers, we require a certain amount of extra space in the blocks to accommodate padding (a minimum of 1 bytes for PKCS5 padding, for example). DKS TODO -- deal with the padding and length expansion For the moment, until we deal with padding we use only AES-CTR. </li>
</ul>
<p>
Overall this class attempts to minimize copying of data. Data must be copied into final ContentObjects returned by the signing operations. On the way, it may need to pass through a block encrypter, which may perform local copies. Higher-level constructs, such as streams, may buffer it above. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6270483ef281895470732b058c67cb68"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::CCNSegmenter" ref="6270483ef281895470732b058c67cb68" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.CCNSegmenter.CCNSegmenter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1config_1_1_configuration_exception.html">ConfigurationException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a segmenter with default (Merkle hash tree) bulk signing behavior, making a new handle for it to use. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ConfigurationException</em>&nbsp;</td><td>if there is a problem creating the handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if there is a problem creating the handle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="897605a8a0b8362cdab1148822d6f824"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::CCNSegmenter" ref="897605a8a0b8362cdab1148822d6f824" args="(CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.CCNSegmenter.CCNSegmenter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a segmenter with default (Merkle hash tree) bulk signing behavior. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle to use, will open a new one if null </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if there is a problem creating the handle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f4de398987fee9331bb1ef65c4ebc59"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::CCNSegmenter" ref="7f4de398987fee9331bb1ef65c4ebc59" args="(CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.CCNSegmenter.CCNSegmenter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a segmenter with default (Merkle hash tree) bulk signing behavior. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the specified flow controller to use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="67d2dd38c5b73daf51d3d68585dca62f"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::CCNSegmenter" ref="67d2dd38c5b73daf51d3d68585dca62f" args="(CCNFlowControl flowControl, CCNAggregatedSigner signer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.CCNSegmenter.CCNSegmenter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_aggregated_signer.html">CCNAggregatedSigner</a>&nbsp;</td>
          <td class="paramname"> <em>signer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a segmenter, specifying the signing behavior to use. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the specified flow controller to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signer</em>&nbsp;</td><td>the bulk signer to use. If null, will use default Merkle hash tree behavior. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d88c86629cd8e761c03d76f25757eef3"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getBlockSegmenter" ref="d88c86629cd8e761c03d76f25757eef3" args="(int blockSize, CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a> org.ccnx.ccn.impl.CCNSegmenter.getBlockSegmenter           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory method to create a standard segmenter that generates blocks of fixed length in bytes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>number of bytes to put in each block (the last block will have an odd number of bytes) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the flow controller to use </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new segmenter </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b3385e178bb310da868068c4acf89bc"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getScaledByteCountSegmenter" ref="4b3385e178bb310da868068c4acf89bc" args="(int scale, CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a> org.ccnx.ccn.impl.CCNSegmenter.getScaledByteCountSegmenter           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory method to create a standard segmenter that generates blocks of variable length in bytes, whose segment numbers are scaled by a fixed increment. 
<p>
This could be used, for example to generate segments that had variable number of bytes in each, and naming them by scaling the byte offset by a scale useful to the application - e.g. to end up with millisecond offsets for a video or audio stream, etc. NOTE: the reader infrastructure currently expects incrementing segment numbers; a special stream class is necessary to read data generated this way. That would not be difficult to write. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>multiplier to apply to the byte count before recording it as a sequence number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the flow controller to use </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new segmenter </dd></dl>

</div>
</div><p>
<a class="anchor" name="1570a8c5b3a3db4505a88e107c654f26"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getByteCountSegmenter" ref="1570a8c5b3a3db4505a88e107c654f26" args="(CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a> org.ccnx.ccn.impl.CCNSegmenter.getByteCountSegmenter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory method to create a standard segmenter that generates blocks of variable length in bytes, whose segment numbers are scaled by a fixed increment. 
<p>
This could be used, for example to generate segments that had variable number of bytes in each, and naming them by byte offset. NOTE: This is used by CCNBlockInputStream and CCNBlockOutputStream; the other stream classes will not read data generated this way. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the flow controller to use </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new segmenter </dd></dl>

</div>
</div><p>
<a class="anchor" name="c8f58ebde44d814fab179c03b6a4cc28"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getFirstSegment" ref="c8f58ebde44d814fab179c03b6a4cc28" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> org.ccnx.ccn.impl.CCNSegmenter.getFirstSegment           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the first segment. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The first segment or null if no segments generated yet </dd></dl>

</div>
</div><p>
<a class="anchor" name="06cfa8f913ab06e33ada929528cc65d4"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setBlockSize" ref="06cfa8f913ab06e33ada929528cc65d4" args="(int blockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.CCNSegmenter.setBlockSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the segmentation block size to use. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>block size in bytes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4f57d387423dfa4d1503e6a53e03068e"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getBlockSize" ref="4f57d387423dfa4d1503e6a53e03068e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.CCNSegmenter.getBlockSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current block size. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>block size in bytes </dd></dl>

</div>
</div><p>
<a class="anchor" name="eef4920f19ba49caf9e3bd4a6952f8fe"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setBlockIncrement" ref="eef4920f19ba49caf9e3bd4a6952f8fe" args="(int blockIncrement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.CCNSegmenter.setBlockIncrement           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockIncrement</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the increment between block numbers. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockIncrement</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3a4a8bfb37ee330526da89338506a966"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getBlockIncrement" ref="3a4a8bfb37ee330526da89338506a966" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.CCNSegmenter.getBlockIncrement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the increment between block numbers. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="6c5b218290df2c29a2ea532d2fb4e9e7"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::put" ref="6c5b218290df2c29a2ea532d2fb4e9e7" args="(ContentName name, byte[] content, int offset, int length, boolean lastSegments, SignedInfo.ContentType type, Integer freshnessSeconds, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.put           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>lastSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SignedInfo.ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Puts a complete data item, segmenting it if necessary. 
<p>
The assumption of this method is that this single call puts all the blocks of the item; if multiple calls to the segmenter will be required to output an item, use other methods to manage segment identifiers.<p>
If the data is small enough this doesn't fragment. Otherwise, does. If multi-fragment, uses the naming profile and specified bulk signer (default: Merkle Hash Tree) to generate names and signatures. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>ContentObject of the data that was put (in the case of fragmented data, the first fragment is returned). This way the caller can then easily link to the data if they need to, or put again with a different name. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="408b24e3d72e569510e8544692af9cc4"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::fragmentedPut" ref="408b24e3d72e569510e8544692af9cc4" args="(ContentName name, byte[] content, int offset, int length, Long finalSegmentIndex, SignedInfo.ContentType type, Integer freshnessSeconds, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.fragmentedPut           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>finalSegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SignedInfo.ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException,  	IOException, InvalidAlgorithmParameterException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Segments content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network. 
<p>
Low-level segmentation interface. Assume arguments have been cleaned prior to arrival -- name is not already segmented, type is set, etc.<p>
Starts segmentation at segment SegmentationProfile().baseSegment(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name prefix to use for the segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>content buffer containing content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into buffer at which to start reading content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of buffer to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalSegmentIndex</em>&nbsp;</td><td>the expected segment number of the last segment of this stream, null to omit, Long(-1) to set as the last segment of this put, whatever its number turns out to be </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freshnessSeconds</em>&nbsp;</td><td>the number of seconds this content should be considered fresh, or null to leave unset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the publisher to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the segment identifier for the next segment to be written, if any. If the caller doesn't want to override this, they can hand this number back to a subsequent call to fragmentedPut. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="027eca3398093134eba0f4af87659022"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::fragmentedPut" ref="027eca3398093134eba0f4af87659022" args="(ContentName name, long baseSegmentNumber, byte[] content, int offset, int length, int blockWidth, ContentType type, CCNTime timestamp, Integer freshnessSeconds, Long finalSegmentIndex, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.fragmentedPut           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>baseSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>finalSegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException,  			SignatureException, IOException,  			InvalidAlgorithmParameterException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Segments content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network. 
<p>
NOTE - ControlFlow.addNameSpace must be done before calling this<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name prefix to use for the segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseSegmentNumber</em>&nbsp;</td><td>the segment number to start this batch with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>content buffer containing content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into buffer at which to start reading content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of buffer to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockWidth</em>&nbsp;</td><td>the block size to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>the timestamp for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freshnessSeconds</em>&nbsp;</td><td>the number of seconds this content should be considered fresh, or null to leave unset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalSegmentIndex</em>&nbsp;</td><td>the expected segment number of the last segment of this stream, null to omit, Long(-1) to set as the last segment of this put, whatever its number turns out to be </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the publisher to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the segment identifier for the next segment to be written, if any. If the caller doesn't want to override this, they can hand this number back to a subsequent call to fragmentedPut. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#408b24e3d72e569510e8544692af9cc4" title="Segments content, builds segment names and ContentObjects, signs them, and writes...">fragmentedPut</a>(ContentName, byte[], int, int, Long, ContentType, Integer, KeyLocator, PublisherPublicKeyDigest) Starts segmentation at segment SegmentationProfile().baseSegment(). </dd></dl>

</div>
</div><p>
<a class="anchor" name="552e7a88a116e72a7bdb1f92c0d1950f"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::fragmentedPut" ref="552e7a88a116e72a7bdb1f92c0d1950f" args="(ContentName name, long baseSegmentNumber, byte contentBlocks[][], int blockCount, int firstBlockIndex, int lastBlockLength, ContentType type, CCNTime timestamp, Integer freshnessSeconds, Long finalSegmentIndex, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.fragmentedPut           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>baseSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlocks</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>firstBlockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastBlockLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>finalSegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, SignatureException,  			NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes pre-segmented content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name prefix to use for the segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseSegmentNumber</em>&nbsp;</td><td>the segment number to start this batch with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentBlocks</em>&nbsp;</td><td>content buffers containing content to put, one buffer per ContentObject </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockCount</em>&nbsp;</td><td>the number of these content buffers to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>firstBlockIndex</em>&nbsp;</td><td>the index into the content buffer array to start writing blocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastBlockLength</em>&nbsp;</td><td>the number of bytes of the last block to be written to use -- this allows a fixed set of byte [] to be used to buffer content for segmentation, and still cope with variable-length last blocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>the timestamp for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freshnessSeconds</em>&nbsp;</td><td>the number of seconds this content should be considered fresh, or null to leave unset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalSegmentIndex</em>&nbsp;</td><td>the expected segment number of the last segment of this stream, null to omit, Long(-1) to set as the last segment of this put, whatever its number turns out to be </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the publisher to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the segment identifier for the next segment to be written, if any. If the caller doesn't want to override this, they can hand this number back to a subsequent call to fragmentedPut. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#408b24e3d72e569510e8544692af9cc4" title="Segments content, builds segment names and ContentObjects, signs them, and writes...">fragmentedPut</a>(ContentName, byte[], int, int, Long, ContentType, Integer, KeyLocator, PublisherPublicKeyDigest) Starts segmentation at segment SegmentationProfile().baseSegment(). </dd></dl>

</div>
</div><p>
<a class="anchor" name="06f2c591b18d93fdf2e36e1171b97f56"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::outputCurrentBlocks" ref="06f2c591b18d93fdf2e36e1171b97f56" args="(PrivateKey signingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.CCNSegmenter.outputCurrentBlocks           </td>
          <td>(</td>
          <td class="paramtype">PrivateKey&nbsp;</td>
          <td class="paramname"> <em>signingKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sign and output all outstanding blocks to the flow controller. 
<p>
This is done when the number of blocks reaches HOLD_COUNT (see above) or we are doing a final flush of a file.<p>
There are 2 cases: 1) we're flushing a single block and can put it out with a straight signature (includes 0-length file case) 2) we're flushing more than one block, and need to use a bulk signer.<p>
All code is capable of handling any mix of these types of blocks but internal mixing should not happen anymore unless we decide to add a higher level capability to allow an immediate flush all the way to the flow controller. Normally we would see groups of bulk signatures followed by a straight signature block in rare cases where only a single block is left over for the flush after a bulk signing pass.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signingKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalFlush</em>&nbsp;</td><td>sign and dump everything if true </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e9230fc0c4e7270d80bc92a88a55dc08"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::putFragment" ref="e9230fc0c4e7270d80bc92a88a55dc08" args="(ContentName name, long segmentNumber, byte[] content, int offset, int length, ContentType type, CCNTime timestamp, Integer freshnessSeconds, Long finalSegmentIndex, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.putFragment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>segmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>finalSegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, SignatureException,  			NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Puts a single block of content of arbitrary length using a segment naming convention. 
<p>
The only current use of this is to allow a Segmenter.put of less than a blocksize. I'm not quite sure why that needs to use this and it would be nice to get rid of this since its mostly superfluous and duplicating other code at this point but for now I'll leave it in.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name prefix to use for the object, without the segment number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>segmentNumber</em>&nbsp;</td><td>the segment number to use for this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>content buffer containing content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into buffer at which to start reading content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of buffer to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>the timestamp for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freshnessSeconds</em>&nbsp;</td><td>the number of seconds this content should be considered fresh, or null to leave unset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalSegmentIndex</em>&nbsp;</td><td>the expected segment number of the last segment of this stream, null to omit, Long(-1) to set as the last segment of this put, whatever its number turns out to be </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the publisher to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the segment identifier for the next segment to be written, if any. If the caller doesn't want to override this, they can hand this number back to a subsequent call to fragmentedPut. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cfa807b1bbd0ac7ecf81e759b5cbb930"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::buildBlocks" ref="cfa807b1bbd0ac7ecf81e759b5cbb930" args="(ContentName rootName, long baseSegmentNumber, SignedInfo signedInfo, byte[] content, int offset, int length, int blockWidth, ContentKeys keys, PrivateKey signingKey, boolean finalFlush)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.buildBlocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>rootName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>baseSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_signed_info.html">SignedInfo</a>&nbsp;</td>
          <td class="paramname"> <em>signedInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrivateKey&nbsp;</td>
          <td class="paramname"> <em>signingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>finalFlush</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, InvalidAlgorithmParameterException, IOException, SignatureException, NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper method to build ContentObjects for segments out of a contiguous buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rootName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseSegmentNumber</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signedInfo</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockWidth</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signingKey</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="04f5e2309a3ad4437350d374367fa0d8"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::newBlock" ref="04f5e2309a3ad4437350d374367fa0d8" args="(ContentName rootName, long segmentNumber, SignedInfo signedInfo, byte contentBlock[], int offset, int blockLength, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.newBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>rootName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>segmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_signed_info.html">SignedInfo</a>&nbsp;</td>
          <td class="paramname"> <em>signedInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlock</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, InvalidAlgorithmParameterException, ContentEncodingException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a ContentObject, encrypt it if requested, and add it to the list of ContentObjects awaiting signing and output to the flow controller. 
<p>
Also creates the segmented name for the CO.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rootName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>segmentNumber</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signedInfo</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentBlock</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockLength</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>next segment number to use </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2ad60cb766d3419a5e1e16483f2a36c2"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::nextSegmentIndex" ref="2ad60cb766d3419a5e1e16483f2a36c2" args="(long lastSegmentNumber, long lastSegmentLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.nextSegmentIndex           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lastSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lastSegmentLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increment segment number according to the numbering profile in force. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lastSegmentNumber</em>&nbsp;</td><td>the last segment number we emitted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastSegmentLength</em>&nbsp;</td><td>the length of the last segment we emitted </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="42cece4ed08a698e7fa26eb74d2a80e0"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::lastSegmentIndex" ref="42cece4ed08a698e7fa26eb74d2a80e0" args="(long currentSegmentNumber, long bytesIntervening, int blocksRemaining)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Long org.ccnx.ccn.impl.CCNSegmenter.lastSegmentIndex           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>currentSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bytesIntervening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blocksRemaining</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the index of the last block of a set of segments, according to the numbering profile. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSegmentNumber</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytesIntervening</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocksRemaining</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="07015cd40f6afaa8818baf63b4537342"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setTimeout" ref="07015cd40f6afaa8818baf63b4537342" args="(int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.CCNSegmenter.setTimeout           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the timeout on the contained flow controller. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fa5cd186cdde6d267642c82fe318b735"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::outputLength" ref="fa5cd186cdde6d267642c82fe318b735" args="(int inputLength, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.outputLength           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>inputLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
How many content bytes will it take to represent content of length length, including any padding incurred by encryption? 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inputLength</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the output length </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="0bdb3b5d7333606709c78200478a510c"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_bulkSigner" ref="0bdb3b5d7333606709c78200478a510c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_aggregated_signer.html">CCNAggregatedSigner</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#0bdb3b5d7333606709c78200478a510c">org.ccnx.ccn.impl.CCNSegmenter._bulkSigner</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handle multi-block amortized signing. 
<p>
If null, default to single-block signing. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/impl/CCNSegmenter.java</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Sep 14 12:44:25 2011 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
