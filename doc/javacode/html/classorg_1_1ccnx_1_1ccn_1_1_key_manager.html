<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Content-Centric Networking in Java: org.ccnx.ccn.KeyManager Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.KeyManager Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::KeyManager" -->Top-level interface for managing our own keys, as well as maintaining an address book containing the keys of others (which will be used by the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_trust_manager.html" title="Basic interface to trust management -- determination of whether a piece of content...">TrustManager</a>).  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for org.ccnx.ccn.KeyManager:</div>
<div class="dynsection">

<p><center><img src="classorg_1_1ccnx_1_1ccn_1_1_key_manager.png" usemap="#org.ccnx.ccn.KeyManager_map" border="0" alt=""></center>
<map name="org.ccnx.ccn.KeyManager_map">
<area href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html" alt="org.ccnx.ccn.impl.security.keys.BasicKeyManager" shape="rect" coords="0,56,329,80">
<area href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_network_key_manager.html" alt="org.ccnx.ccn.impl.security.keys.NetworkKeyManager" shape="rect" coords="0,112,329,136">
<area href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_repository_key_manager.html" alt="org.ccnx.ccn.impl.security.keys.RepositoryKeyManager" shape="rect" coords="0,168,329,192">
</map>
</div>

<p>
<a href="classorg_1_1ccnx_1_1ccn_1_1_key_manager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98e9ea33f59b2118f72c4e44de535841"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultVerifier" ref="98e9ea33f59b2118f72c4e44de535841" args="()" -->
<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_content_verifier.html">ContentVerifier</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#98e9ea33f59b2118f72c4e44de535841">getDefaultVerifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclasses can override with fancier verification behavior; again move to <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_trust_manager.html" title="Basic interface to trust management -- determination of whether a piece of content...">TrustManager</a> eventually. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#735f99d7970122a1d2cb73ef6f60f18a">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close any connections we have to the network.  <a href="#735f99d7970122a1d2cb73ef6f60f18a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#2260e75206ba67db57094276492cb5b8">initialize</a> ()  throws InvalidKeyException, IOException, ConfigurationException</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows subclasses to specialize key manager initialization.  <a href="#2260e75206ba67db57094276492cb5b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f46065ad140d7af046f3c3c1ccc7f5b"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::initialized" ref="6f46065ad140d7af046f3c3c1ccc7f5b" args="()" -->
abstract boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>initialized</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cac72ef9597bf4edbcdb75fa42c252be"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::clearSavedConfigurationState" ref="cac72ef9597bf4edbcdb75fa42c252be" args="()" -->
abstract void&nbsp;</td><td class="memItemRight" valign="bottom"><b>clearSavedConfigurationState</b> ()  throws FileNotFoundException, IOException</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#bb2951303b1ed33d79338e628c07db16">getDefaultKeyID</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get our default key ID.  <a href="#bb2951303b1ed33d79338e628c07db16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de98fa455c3f0957647cac0fdc0a85d5"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::isOurDefaultKey" ref="de98fa455c3f0957647cac0fdc0a85d5" args="(PublisherPublicKeyDigest keyID)" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>isOurDefaultKey</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_public_key_cache.html">PublicKeyCache</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#d12bf1720ed79d198e5433ca23c66e22">getPublicKeyCache</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access our collected store of public keys.  <a href="#d12bf1720ed79d198e5433ca23c66e22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_secure_key_cache.html">SecureKeyCache</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#089783fd86ce5acfcb8755037becda01">getSecureKeyCache</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access our store of private keys and other secret key material that we have retrieved.  <a href="#089783fd86ce5acfcb8755037becda01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="329cf9711cc5452da48bd51d24718555"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::saveSecureKeyCache" ref="329cf9711cc5452da48bd51d24718555" args="()" -->
abstract void&nbsp;</td><td class="memItemRight" valign="bottom"><b>saveSecureKeyCache</b> ()  throws FileNotFoundException, IOException</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0fe9e27de477888bc28c5e064648d34d"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::saveConfigurationState" ref="0fe9e27de477888bc28c5e064648d34d" args="()" -->
abstract void&nbsp;</td><td class="memItemRight" valign="bottom"><b>saveConfigurationState</b> ()  throws FileNotFoundException, 			IOException</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract URI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#eddd2905916476d95206b817684c2238">getConfigurationDataURI</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not sure that this is the best idea, but others want to bootstrap on our configuration data store to stash their own config data.  <a href="#eddd2905916476d95206b817684c2238"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract PrivateKey&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#a079cfce6435e565054d3e0183930336">getDefaultSigningKey</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get our default private key.  <a href="#a079cfce6435e565054d3e0183930336"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract PublicKey&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#fbbd2a6737f0b05ac3683deb769fe5bf">getDefaultPublicKey</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get our default public key.  <a href="#fbbd2a6737f0b05ac3683deb769fe5bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#5985f7607754d92b3a35804624603611">getDefaultKeyName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyPrefix, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> keyVersion)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the key's content name for a given key id, given a specified prefix and version.  <a href="#5985f7607754d92b3a35804624603611"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#efbed20a3fbd48bb7daabff520b3fa03">getDefaultKeyName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the key-manager determined default key name for a key.  <a href="#efbed20a3fbd48bb7daabff520b3fa03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="93521794313c11f87a089738f5f03cb9"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultKeyNamePrefix" ref="93521794313c11f87a089738f5f03cb9" args="()" -->
abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#93521794313c11f87a089738f5f03cb9">getDefaultKeyNamePrefix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow subclasses to override default publishing location. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#62322d9fe82929c50d32e635acf83b65">getKeyLocator</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisherKeyID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the preferred key locator for this signing key.  <a href="#62322d9fe82929c50d32e635acf83b65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#8d6fd603f66a72ef593836a3bce4cd87">getKeyLocator</a> (PrivateKey signingKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get our current preferred key locator for this signing key.  <a href="#8d6fd603f66a72ef593836a3bce4cd87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#82da7b19db941cb739579a33d96815e2">getDefaultKeyLocator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the key locator for our default key.  <a href="#82da7b19db941cb739579a33d96815e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a58c1dc1ba07d2e8e8be504b6c42939"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::haveStoredKeyLocator" ref="9a58c1dc1ba07d2e8e8be504b6c42939" args="(PublisherPublicKeyDigest keyID)" -->
abstract boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>haveStoredKeyLocator</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="709a36069e0f23dbbc42ab37e805422c"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getStoredKeyLocator" ref="709a36069e0f23dbbc42ab37e805422c" args="(PublisherPublicKeyDigest keyID)" -->
abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getStoredKeyLocator</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8202c5d9f7c854da11e8527784c10f42"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::clearStoredKeyLocator" ref="8202c5d9f7c854da11e8527784c10f42" args="(PublisherPublicKeyDigest keyID)" -->
abstract void&nbsp;</td><td class="memItemRight" valign="bottom"><b>clearStoredKeyLocator</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#d8884ba6ba0c82962be4c9432f11a526">setKeyLocator</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisherKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> keyLocator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remember the key locator to use for a given key.  <a href="#d8884ba6ba0c82962be4c9432f11a526"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#77fd490c70bda4c0fab6814ac1c8b7a1">getKeyTypeKeyLocator</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisherKeyID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a KEY type key locator for a particular public key.  <a href="#77fd490c70bda4c0fab6814ac1c8b7a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract PublicKey&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#b983de5f9e0df1580cc8c5181aa653b9">getPublicKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the public key associated with a given publisher.  <a href="#b983de5f9e0df1580cc8c5181aa653b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#e00bac5027648c50188775079504168e">getPublisherKeyID</a> (PrivateKey signingKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the publisher key digest associated with one of our signing keys.  <a href="#e00bac5027648c50188775079504168e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract PrivateKey&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#f5ae31400501fd7123db839d50223af5">getSigningKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisherKeyID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the private key associated with a given publisher.  <a href="#f5ae31400501fd7123db839d50223af5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract PrivateKey[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#145ed6a79ebf0597d2a5881f0b5f4172">getSigningKeys</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all of our private keys, used for cache loading.  <a href="#145ed6a79ebf0597d2a5881f0b5f4172"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="18ffca1aa256a18a45b282cf09bccb29"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getAvailableIdentities" ref="18ffca1aa256a18a45b282cf09bccb29" args="()" -->
abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#18ffca1aa256a18a45b282cf09bccb29">getAvailableIdentities</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the public key digest of all our signing keys -- essentially our available identities. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#0e6eb0720d3284a0b38fbb7cf687c884">getKeyVersion</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get any timestamp associate with this key.  <a href="#0e6eb0720d3284a0b38fbb7cf687c884"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract PublicKey&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#7aa5e95819d6e76f3f5191070b8b48b3">getPublicKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisherKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> keyLocator, long timeout)  throws IOException</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the public key for a given publisher, going to the network to retrieve it if necessary.  <a href="#7aa5e95819d6e76f3f5191070b8b48b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PublicKey&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#096e52d557cffca508c8e37913f1d6b1">getPublicKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisherKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> keyLocator)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the public key for a given publisher, going to the network to retrieve it if necessary.  <a href="#096e52d557cffca508c8e37913f1d6b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#af2859ee5f6bd4eea7f0fa64c5e44244">getPublicKeyObject</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> desiredKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, long timeout)  throws IOException</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the public key for a given publisher as it was explicitly published, going to the network to retrieve it if necessary.  <a href="#af2859ee5f6bd4eea7f0fa64c5e44244"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#5bc202dbc94047a86f322a48bb937b6e">publishDefaultKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName)  throws IOException, InvalidKeyException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow subclasses to specialize key publication, if any.  <a href="#5bc202dbc94047a86f322a48bb937b6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#fc4e150ed857c744d3476ddad92316ee">publishKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyToPublish, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> signingKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> signingKeyLocator)  throws InvalidKeyException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish a key at a certain name, signed by a specified identity (our default, if null).  <a href="#fc4e150ed857c744d3476ddad92316ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#64db91a313a71f745dfaa4669f241f43">publishSelfSignedKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyToPublish, boolean learnKeyLocator)  throws InvalidKeyException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish my public key to a local key server run in this JVM, as a self-signed key record.  <a href="#64db91a313a71f745dfaa4669f241f43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#a0a3ede54c6a4c195a1980874f786df1">publishKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, PublicKey keyToPublish, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> signingKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> signingKeyLocator, boolean learnKeyLocator)  throws InvalidKeyException, IOException</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish a key at a certain name, signed by our default identity.  <a href="#a0a3ede54c6a4c195a1980874f786df1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#47cd2028fef0bec6567ea408ca377650">publishKeyToRepository</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyToPublish, long timeToWaitForPreexisting)  throws InvalidKeyException, IOException</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish a key at a certain name, ensuring that it is stored in a repository.  <a href="#47cd2028fef0bec6567ea408ca377650"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#cb052817bf60940bf1cd9511042898a2">publishSelfSignedKeyToRepository</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, PublicKey theKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyToPublish, long timeToWaitForPreexisting)  throws InvalidKeyException, IOException</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish one of our keys to a repository, if it isn't already there, and ensure that it's self-signed regardless of what credentials we have for it (this is the default behavior if we have no credentials for the key.  <a href="#cb052817bf60940bf1cd9511042898a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#04f0bb9ed438b48f861c6b4d29c4ccf5">publishKeyToRepository</a> ()  throws InvalidKeyException, IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish our default key to a repository at its default location.  <a href="#04f0bb9ed438b48f861c6b4d29c4ccf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83d207fc6ed31dcb02df1ffbf064c2ee"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishKeyToRepository" ref="83d207fc6ed31dcb02df1ffbf064c2ee" args="(ContentName keyName, PublisherPublicKeyDigest keyToPublish)" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>publishKeyToRepository</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> keyToPublish)  throws InvalidKeyException, IOException </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#f9dbc7983a641c7df5b48e652748da59">respondToKeyRequests</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyPrefix)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Right now KeyServers are hidden in our subclasses.  <a href="#f9dbc7983a641c7df5b48e652748da59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1_access_control_manager.html">AccessControlManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#63fb9107967123fc7add2a6a69f78115">getAccessControlManagerForName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> contentName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle access control manager cache.  <a href="#63fb9107967123fc7add2a6a69f78115"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="50e5efbac1c48e7f4536ef096b304acd"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::rememberAccessControlManager" ref="50e5efbac1c48e7f4536ef096b304acd" args="(AccessControlManager acm)" -->
abstract void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rememberAccessControlManager</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1_access_control_manager.html">AccessControlManager</a> acm)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static synchronized <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#6fc5bccc4f6fac3d73bad3a45069cbe3">getDefaultKeyManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor to retrieve default key manager instance, or create it if necessary.  <a href="#6fc5bccc4f6fac3d73bad3a45069cbe3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#e90d53ce04456184f93e16925eb59402">closeDefaultKeyManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean up state left around by the default key manager and remove it.  <a href="#e90d53ce04456184f93e16925eb59402"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#a3071e5325667feec1be071b08d184ef">setDefaultKeyManager</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a> keyManager)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the default key manager to one of our choice.  <a href="#a3071e5325667feec1be071b08d184ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#126b37dab07f2b7b5f736653c8a857bd">publishKeyToRepository</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, PublicKey keyToPublish, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> signingKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> signingKeyLocator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish a public key to repository, if it isn't already there.  <a href="#126b37dab07f2b7b5f736653c8a857bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#a1ebb6ad1308022b034528e2f8b481c8">publishKeyToRepository</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, PublicKey keyToPublish, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> signingKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> signingKeyLocator, long timeToWaitForPreexisting, boolean requirePublisherMatch, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish a public key to repository, if it isn't already there.  <a href="#a1ebb6ad1308022b034528e2f8b481c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#668e26727f0f1e087ee041ffc12848f7">publishKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyName, PublicKey keyToPublish, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> signingKeyID, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> signingKeyLocator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowController, SaveType saveType, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a> keyManager)  throws IOException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note: this is the lowest level interface to key publication; there are many higher-level interfaces that are probably what you want.  <a href="#668e26727f0f1e087ee041ffc12848f7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static final String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#8c9103e88fbe49c1a140446e88a9ca44">DEFAULT_DIGEST_ALGORITHM</a> = &quot;SHA-256&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Currently default to SHA-256.  <a href="#8c9103e88fbe49c1a140446e88a9ca44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27de14ed7586f4cfb8e54ed6ebc350fb"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::PROVIDER" ref="27de14ed7586f4cfb8e54ed6ebc350fb" args="" -->
static final Provider&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROVIDER</b> = getBcProvider()</td></tr>

<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static synchronized <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#5bc1101723de511b5cc73e2002dafa1f">createDefaultKeyManager</a> ()  throws InvalidKeyException, IOException, ConfigurationException </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the default key manager.  <a href="#5bc1101723de511b5cc73e2002dafa1f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_content_verifier.html">ContentVerifier</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#11ff3dc4a455536a93ead43cf77b053c">_verifier</a> = null</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A default verifier to use, relative to these key caches and all.  <a href="#11ff3dc4a455536a93ead43cf77b053c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="42b0bb4a98a1fb7fea8827badd7e19fb"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::SELF_SIGNED_KEY_LOCATOR" ref="42b0bb4a98a1fb7fea8827badd7e19fb" args="" -->
static final <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#42b0bb4a98a1fb7fea8827badd7e19fb">SELF_SIGNED_KEY_LOCATOR</a> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Canary value, indicates we want to override any other key locator available. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#5e6db34a1a4e19c1f8496a38a54563ac">_defaultKeyManager</a> = null</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html" title="Top-level interface for managing our own keys, as well as maintaining an address...">KeyManager</a> for this user/VM pair.  <a href="#5e6db34a1a4e19c1f8496a38a54563ac"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Top-level interface for managing our own keys, as well as maintaining an address book containing the keys of others (which will be used by the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_trust_manager.html" title="Basic interface to trust management -- determination of whether a piece of content...">TrustManager</a>). 
<p>
Also handles loading of the BouncyCastle provider, which we need for many things. Very minimal interface now, expect to evolve extensively. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6fc5bccc4f6fac3d73bad3a45069cbe3"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultKeyManager" ref="6fc5bccc4f6fac3d73bad3a45069cbe3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static synchronized <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a> org.ccnx.ccn.KeyManager.getDefaultKeyManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor to retrieve default key manager instance, or create it if necessary. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html" title="Top-level interface for managing our own keys, as well as maintaining an address...">KeyManager</a> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ConfigurationException</em>&nbsp;</td><td>if there is a problem with the user or system configuration that requires intervention to resolve, or we have a significant problem starting up the key manager. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e90d53ce04456184f93e16925eb59402"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::closeDefaultKeyManager" ref="e90d53ce04456184f93e16925eb59402" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static synchronized void org.ccnx.ccn.KeyManager.closeDefaultKeyManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clean up state left around by the default key manager and remove it. 
<p>
For now that just means shutting down the network manager started by it 
</div>
</div><p>
<a class="anchor" name="5bc1101723de511b5cc73e2002dafa1f"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::createDefaultKeyManager" ref="5bc1101723de511b5cc73e2002dafa1f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static synchronized <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a> org.ccnx.ccn.KeyManager.createDefaultKeyManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, IOException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1config_1_1_configuration_exception.html">ConfigurationException</a> <code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the default key manager. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the key manager </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ConfigurationException</em>&nbsp;</td><td>if there is a problem with the user or system configuration that requires intervention to fix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if there is an operational problem loading data or initializing the key store </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigurationException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a3071e5325667feec1be071b08d184ef"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::setDefaultKeyManager" ref="a3071e5325667feec1be071b08d184ef" args="(KeyManager keyManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static synchronized void org.ccnx.ccn.KeyManager.setDefaultKeyManager           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a>&nbsp;</td>
          <td class="paramname"> <em>keyManager</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the default key manager to one of our choice. 
<p>
If you do this, be careful on calling <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#735f99d7970122a1d2cb73ef6f60f18a" title="Close any connections we have to the network.">close()</a>. 
</div>
</div><p>
<a class="anchor" name="735f99d7970122a1d2cb73ef6f60f18a"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::close" ref="735f99d7970122a1d2cb73ef6f60f18a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.KeyManager.close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close any connections we have to the network. 
<p>
Ideally prepare to reopen them when they are next needed. 
<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#8d6106c91553b8a1c7c85828221c2a21">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="2260e75206ba67db57094276492cb5b8"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::initialize" ref="2260e75206ba67db57094276492cb5b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract void org.ccnx.ccn.KeyManager.initialize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, IOException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1config_1_1_configuration_exception.html">ConfigurationException</a><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows subclasses to specialize key manager initialization. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ConfigurationException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#fdb27b80a18f3fc9a4a34a799b6b7d70">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="bb2951303b1ed33d79338e628c07db16"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultKeyID" ref="bb2951303b1ed33d79338e628c07db16" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> org.ccnx.ccn.KeyManager.getDefaultKeyID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get our default key ID. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the digest of our default key </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#5d84fff4ce5cda670a9124e0dd71c160">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="d12bf1720ed79d198e5433ca23c66e22"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getPublicKeyCache" ref="d12bf1720ed79d198e5433ca23c66e22" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_public_key_cache.html">PublicKeyCache</a> org.ccnx.ccn.KeyManager.getPublicKeyCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access our collected store of public keys. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>our PublicKeyCache </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#c6f3df527a3c2c87bad791660557b2b0">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="089783fd86ce5acfcb8755037becda01"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getSecureKeyCache" ref="089783fd86ce5acfcb8755037becda01" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_secure_key_cache.html">SecureKeyCache</a> org.ccnx.ccn.KeyManager.getSecureKeyCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access our store of private keys and other secret key material that we have retrieved. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>our SecureKeyCache </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#a2e541bcf65b3ed183b3a00413b621bf">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="eddd2905916476d95206b817684c2238"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getConfigurationDataURI" ref="eddd2905916476d95206b817684c2238" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract URI org.ccnx.ccn.KeyManager.getConfigurationDataURI           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Not sure that this is the best idea, but others want to bootstrap on our configuration data store to stash their own config data. 
<p>
Return location as a URI as it might be a namespace rather than a directory. 
<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#5fb16a3cdce70baf2fa7e04b922d687a">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>, and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_network_key_manager.html#a0e9826a171183c71627a080efffc1b0">org.ccnx.ccn.impl.security.keys.NetworkKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="a079cfce6435e565054d3e0183930336"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultSigningKey" ref="a079cfce6435e565054d3e0183930336" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract PrivateKey org.ccnx.ccn.KeyManager.getDefaultSigningKey           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get our default private key. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>our default private key </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#d7f73664afeae7969ee59d748f8105ff">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="fbbd2a6737f0b05ac3683deb769fe5bf"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultPublicKey" ref="fbbd2a6737f0b05ac3683deb769fe5bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract PublicKey org.ccnx.ccn.KeyManager.getDefaultPublicKey           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get our default public key. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>our default public key </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#76b1010f462a5b8c9cf2f14c9d16177c">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="5985f7607754d92b3a35804624603611"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultKeyName" ref="5985f7607754d92b3a35804624603611" args="(ContentName keyPrefix, PublisherPublicKeyDigest keyID, CCNTime keyVersion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.KeyManager.getDefaultKeyName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>keyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td>
          <td class="paramname"> <em>keyVersion</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the key's content name for a given key id, given a specified prefix and version. 
<p>
The default key name is the publisher ID itself, under the user's key collection. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyID[]</em>&nbsp;</td><td>publisher ID </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>content name </dd></dl>

</div>
</div><p>
<a class="anchor" name="efbed20a3fbd48bb7daabff520b3fa03"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultKeyName" ref="efbed20a3fbd48bb7daabff520b3fa03" args="(PublisherPublicKeyDigest keyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.KeyManager.getDefaultKeyName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>keyID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the key-manager determined default key name for a key. 
<p>
Might include a version, might allow caller to save with generated version. 
<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#84231e2a986e9633a4954733d48dd387">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="62322d9fe82929c50d32e635acf83b65"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getKeyLocator" ref="62322d9fe82929c50d32e635acf83b65" args="(PublisherPublicKeyDigest publisherKeyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> org.ccnx.ccn.KeyManager.getKeyLocator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisherKeyID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the preferred key locator for this signing key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>publisherKeyID</em>&nbsp;</td><td>the key whose locator we want to retrieve, if null retrieves the key locator for our default key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the current preferred key locator for that key </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#76916fcc645bb976baf3fc86efea6290">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="8d6fd603f66a72ef593836a3bce4cd87"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getKeyLocator" ref="8d6fd603f66a72ef593836a3bce4cd87" args="(PrivateKey signingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> org.ccnx.ccn.KeyManager.getKeyLocator           </td>
          <td>(</td>
          <td class="paramtype">PrivateKey&nbsp;</td>
          <td class="paramname"> <em>signingKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get our current preferred key locator for this signing key. 
<p>
Uses <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#62322d9fe82929c50d32e635acf83b65" title="Gets the preferred key locator for this signing key.">getKeyLocator(PublisherPublicKeyDigest)</a>. 
<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#fe1541df677485c94e735c23fa56cc53">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="82da7b19db941cb739579a33d96815e2"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getDefaultKeyLocator" ref="82da7b19db941cb739579a33d96815e2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> org.ccnx.ccn.KeyManager.getDefaultKeyLocator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the key locator for our default key. 
<p>
Same as getKeyLocator(null) 
</div>
</div><p>
<a class="anchor" name="d8884ba6ba0c82962be4c9432f11a526"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::setKeyLocator" ref="d8884ba6ba0c82962be4c9432f11a526" args="(PublisherPublicKeyDigest publisherKeyID, KeyLocator keyLocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract void org.ccnx.ccn.KeyManager.setKeyLocator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisherKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>keyLocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remember the key locator to use for a given key. 
<p>
Use this to publish this key in the future if not overridden by method calls. If no key locator stored for this key, and no override given, compute a KEY type key locator if this key has not been published, and the name given to it when published if it has. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>publisherKeyID</em>&nbsp;</td><td>the key whose locator to set; if null sets it for our default key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyLocator</em>&nbsp;</td><td>the new key locator for this key; overrides any previous value. If null, erases previous value and defaults will be used. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#085bf6348776b8dedfca6b702f8e7862">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="77fd490c70bda4c0fab6814ac1c8b7a1"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getKeyTypeKeyLocator" ref="77fd490c70bda4c0fab6814ac1c8b7a1" args="(PublisherPublicKeyDigest publisherKeyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> org.ccnx.ccn.KeyManager.getKeyTypeKeyLocator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisherKeyID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a KEY type key locator for a particular public key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>publisherKeyID</em>&nbsp;</td><td>the key whose locator we want to retrieve </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the key locator </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b983de5f9e0df1580cc8c5181aa653b9"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getPublicKey" ref="b983de5f9e0df1580cc8c5181aa653b9" args="(PublisherPublicKeyDigest publisher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract PublicKey org.ccnx.ccn.KeyManager.getPublicKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the public key associated with a given publisher. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the digest of the desired key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the key, or null if no such key known to our cache </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#f46619a2c9c6a29a53480fcab9ac49cb">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="e00bac5027648c50188775079504168e"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getPublisherKeyID" ref="e00bac5027648c50188775079504168e" args="(PrivateKey signingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> org.ccnx.ccn.KeyManager.getPublisherKeyID           </td>
          <td>(</td>
          <td class="paramtype">PrivateKey&nbsp;</td>
          <td class="paramname"> <em>signingKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the publisher key digest associated with one of our signing keys. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signingKey</em>&nbsp;</td><td>key whose publisher data we want </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the digest of the corresponding public key </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#8a43bf831dd5814c8413779c2af68ef9">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="f5ae31400501fd7123db839d50223af5"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getSigningKey" ref="f5ae31400501fd7123db839d50223af5" args="(PublisherPublicKeyDigest publisherKeyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract PrivateKey org.ccnx.ccn.KeyManager.getSigningKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisherKeyID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the private key associated with a given publisher. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>publisherKeyID</em>&nbsp;</td><td>the public key digest of the desired key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the key, or null if no such key known to our cache </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#1244448e00e475716145d6bf413b8f95">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="145ed6a79ebf0597d2a5881f0b5f4172"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getSigningKeys" ref="145ed6a79ebf0597d2a5881f0b5f4172" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract PrivateKey [] org.ccnx.ccn.KeyManager.getSigningKeys           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get all of our private keys, used for cache loading. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an array of our currently available private keys </dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#0a94950a658c7664c778e86515f9fc2b">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="0e6eb0720d3284a0b38fbb7cf687c884"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getKeyVersion" ref="0e6eb0720d3284a0b38fbb7cf687c884" args="(PublisherPublicKeyDigest keyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> org.ccnx.ccn.KeyManager.getKeyVersion           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>keyID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get any timestamp associate with this key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyID</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#d37f105198e02f7dac91b844c521318f">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="7aa5e95819d6e76f3f5191070b8b48b3"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getPublicKey" ref="7aa5e95819d6e76f3f5191070b8b48b3" args="(PublisherPublicKeyDigest publisherKeyID, KeyLocator keyLocator, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract PublicKey org.ccnx.ccn.KeyManager.getPublicKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisherKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>keyLocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the public key for a given publisher, going to the network to retrieve it if necessary. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>publisherKeyID</em>&nbsp;</td><td>the digest of the keys we want </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyLocator</em>&nbsp;</td><td>the key locator to tell us where to retrieve the key from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>how long to try to retrieve the key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the key </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if we run into an error attempting to read the key </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#5752d5dcde8509dadb74134c470d9161">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="096e52d557cffca508c8e37913f1d6b1"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getPublicKey" ref="096e52d557cffca508c8e37913f1d6b1" args="(PublisherPublicKeyDigest publisherKeyID, KeyLocator keyLocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PublicKey org.ccnx.ccn.KeyManager.getPublicKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisherKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>keyLocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the public key for a given publisher, going to the network to retrieve it if necessary. 
<p>
Uses the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1config_1_1_system_configuration.html#4d06da2717f8f8e6edf513b3c19f7e3f" title="Extra-long timeout, e.g.">SystemConfiguration.EXTRA_LONG_TIMEOUT</a> to be aggressive and reexpress. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>publisherKeyID</em>&nbsp;</td><td>the digest of the keys we want </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyLocator</em>&nbsp;</td><td>the key locator to tell us where to retrieve the key from </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the key </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if we run into an error attempting to read the key </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af2859ee5f6bd4eea7f0fa64c5e44244"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getPublicKeyObject" ref="af2859ee5f6bd4eea7f0fa64c5e44244" args="(PublisherPublicKeyDigest desiredKeyID, KeyLocator locator, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.getPublicKeyObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>desiredKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the public key for a given publisher as it was explicitly published, going to the network to retrieve it if necessary. 
<p>
If the key was not published as a KEY content item (was in our keystore, or was in a KEY type of key locator), this wil not retrieve anything. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>publisherKeyID</em>&nbsp;</td><td>the digest of the keys we want </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyLocator</em>&nbsp;</td><td>the key locator to tell us where to retrieve the key from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>how long to try to retrieve the key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the key </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if we run into an error attempting to read the key </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#fd55663487aed58f933505e374e4dc09">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="5bc202dbc94047a86f322a48bb937b6e"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishDefaultKey" ref="5bc202dbc94047a86f322a48bb937b6e" args="(ContentName keyName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishDefaultKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException, InvalidKeyException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow subclasses to specialize key publication, if any. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>defaultPrefix</em>&nbsp;</td><td>our default namespace, if we know one for this environment. If null, take user defaults. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ConfigurationException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#79046dff401f86e6a6e260cc6388559d">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="fc4e150ed857c744d3476ddad92316ee"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishKey" ref="fc4e150ed857c744d3476ddad92316ee" args="(ContentName keyName, PublisherPublicKeyDigest keyToPublish, PublisherPublicKeyDigest signingKeyID, KeyLocator signingKeyLocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>keyToPublish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyLocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Publish a key at a certain name, signed by a specified identity (our default, if null). 
<p>
Usually used to publish our own keys, but can specify other keys we have in our cache.<p>
This publishes our key to our own internal key server, from where it can be retrieved as long as this <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html" title="Top-level interface for managing our own keys, as well as maintaining an address...">KeyManager</a> is running. It does not put it on the wire until someone requests it. Implementation Note: This code is used in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> initialization, and as such it cannot use a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> or any of the standard network operations without introducing a circular dependency. The code is very low-level and should only be modified with great caution.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyName</em>&nbsp;</td><td>content name of the public key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyToPublish</em>&nbsp;</td><td>public key digest of key to publish, if null publish our default key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>handle for ccn </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="64db91a313a71f745dfaa4669f241f43"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishSelfSignedKey" ref="64db91a313a71f745dfaa4669f241f43" args="(ContentName keyName, PublisherPublicKeyDigest keyToPublish, boolean learnKeyLocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishSelfSignedKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>keyToPublish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>learnKeyLocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Publish my public key to a local key server run in this JVM, as a self-signed key record. 
<p>
We do this by default if we don't have any credentials for this key; this just allows the caller to explicitly request this behavior even if we do have credentials. TODO need mechanism for controlling whether this ends up in the key locator... <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyName</em>&nbsp;</td><td>content name of the public key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyToPublish</em>&nbsp;</td><td>public key digest of key to publish and to sign with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>handle for ccn </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a0a3ede54c6a4c195a1980874f786df1"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishKey" ref="a0a3ede54c6a4c195a1980874f786df1" args="(ContentName keyName, PublicKey keyToPublish, PublisherPublicKeyDigest signingKeyID, KeyLocator signingKeyLocator, boolean learnKeyLocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublicKey&nbsp;</td>
          <td class="paramname"> <em>keyToPublish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyLocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>learnKeyLocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, IOException<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Publish a key at a certain name, signed by our default identity. 
<p>
Usually used to publish our own keys, but can specify other keys we have in our cache.<p>
This publishes our key to our own internal key server, from where it can be retrieved as long as this <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html" title="Top-level interface for managing our own keys, as well as maintaining an address...">KeyManager</a> is running. It does not put it on the wire until someone requests it. Implementation Note: This code is used in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> initialization, and as such it cannot use a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> or any of the standard network operations without introducing a circular dependency. The code is very low-level and should only be modified with great caution.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyName</em>&nbsp;</td><td>the name under which the key should be published. For the moment, keys are unversioned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyToPublish</em>&nbsp;</td><td>can be null, in which case we publish our own default public key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signingKeyID</em>&nbsp;</td><td>key to sign with, if we wish to override default </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signingKeyLocator</em>&nbsp;</td><td>locator to use, if we wish to override default; if null, one will be computed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>learnKeyLocator</em>&nbsp;</td><td>do we remember the key locator used as the default for this signing key </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigurationException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#bc218cd7da041138f6ab27e4ca5dd011">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="47cd2028fef0bec6567ea408ca377650"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishKeyToRepository" ref="47cd2028fef0bec6567ea408ca377650" args="(ContentName keyName, PublisherPublicKeyDigest keyToPublish, long timeToWaitForPreexisting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishKeyToRepository           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>keyToPublish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeToWaitForPreexisting</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, IOException<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Publish a key at a certain name, ensuring that it is stored in a repository. 
<p>
Will throw an exception if no repository available. Usually used to publish our own keys, but can specify any key known to our key cache. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyName</em>&nbsp;</td><td>Name under which to publish the key. Currently added under existing version, or version included in keyName. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyToPublish</em>&nbsp;</td><td>can be null, in which case we publish our own default public key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle to use for network requests </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#df25deb082f6710c655688710f707430">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="cb052817bf60940bf1cd9511042898a2"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishSelfSignedKeyToRepository" ref="cb052817bf60940bf1cd9511042898a2" args="(ContentName keyName, PublicKey theKey, PublisherPublicKeyDigest keyToPublish, long timeToWaitForPreexisting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishSelfSignedKeyToRepository           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublicKey&nbsp;</td>
          <td class="paramname"> <em>theKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>keyToPublish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeToWaitForPreexisting</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, IOException<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Publish one of our keys to a repository, if it isn't already there, and ensure that it's self-signed regardless of what credentials we have for it (this is the default behavior if we have no credentials for the key. 
<p>
Throws an exception if no repository is available <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyName</em>&nbsp;</td><td>Name under which to publish the key. Currently added under existing version, or version included in keyName. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>theKey</em>&nbsp;</td><td>the public key to publish, if we happen to have it; otherwise it will be retrieved from cache based on keyToPublish. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyToPublish</em>&nbsp;</td><td>can be null, in which case we publish our own default public key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle to use for network requests </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#856e7e92ea5f88405f2a7099725cf31e">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="04f0bb9ed438b48f861c6b4d29c4ccf5"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishKeyToRepository" ref="04f0bb9ed438b48f861c6b4d29c4ccf5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishKeyToRepository           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Publish our default key to a repository at its default location. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle used for network requests </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="126b37dab07f2b7b5f736653c8a857bd"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishKeyToRepository" ref="126b37dab07f2b7b5f736653c8a857bd" args="(ContentName keyName, PublicKey keyToPublish, PublisherPublicKeyDigest signingKeyID, KeyLocator signingKeyLocator, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishKeyToRepository           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublicKey&nbsp;</td>
          <td class="paramname"> <em>keyToPublish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyLocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Publish a public key to repository, if it isn't already there. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyName</em>&nbsp;</td><td>content name of the public key to publish under (adds a version) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyToPublish</em>&nbsp;</td><td>the key to publish </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle to use to publish it with </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the published information about this key, whether we published it or someone else had </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a1ebb6ad1308022b034528e2f8b481c8"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishKeyToRepository" ref="a1ebb6ad1308022b034528e2f8b481c8" args="(ContentName keyName, PublicKey keyToPublish, PublisherPublicKeyDigest signingKeyID, KeyLocator signingKeyLocator, long timeToWaitForPreexisting, boolean requirePublisherMatch, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishKeyToRepository           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublicKey&nbsp;</td>
          <td class="paramname"> <em>keyToPublish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyLocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeToWaitForPreexisting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>requirePublisherMatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Publish a public key to repository, if it isn't already there. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyName</em>&nbsp;</td><td>content name of the public key to publish under (adds a version) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyToPublish</em>&nbsp;</td><td>the key to publish </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signingKeyID</em>&nbsp;</td><td>the key to sign with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signingKeyLocator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeToWaitForPreexisting</em>&nbsp;</td><td>how long to wait to see if it has already been published (avoid re-publishing). If 0, we don't even try to find preexisting content. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>requirePublisherMatch</em>&nbsp;</td><td>check to see if we match the specified publisher. Key locator match too complex to check, make caller do that one. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle to use to publish it with </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the published information about this key, whether we published it or someone else had </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="668e26727f0f1e087ee041ffc12848f7"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::publishKey" ref="668e26727f0f1e087ee041ffc12848f7" args="(ContentName keyName, PublicKey keyToPublish, PublisherPublicKeyDigest signingKeyID, KeyLocator signingKeyLocator, CCNFlowControl flowController, SaveType saveType, CCNHandle handle, KeyManager keyManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_public_key_object.html">PublicKeyObject</a> org.ccnx.ccn.KeyManager.publishKey           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublicKey&nbsp;</td>
          <td class="paramname"> <em>keyToPublish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>signingKeyLocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowController</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SaveType&nbsp;</td>
          <td class="paramname"> <em>saveType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a>&nbsp;</td>
          <td class="paramname"> <em>keyManager</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Note: this is the lowest level interface to key publication; there are many higher-level interfaces that are probably what you want. 
<p>
This needs to be public to get across package constraints. Publish a signed record for this key. We've already decided we need to publish, and how; no more checks are made to see if the key already exists.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyName</em>&nbsp;</td><td>the key's content name. Will add a version when saving if it doesn't have one already. If it does have a version, will use that one (see below for effect of version on the key locator). (Note that this is not standard behavior for savable network content, which needs its version explicitly set.) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyToPublish</em>&nbsp;</td><td>the public key to publish </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyID</em>&nbsp;</td><td>the publisher id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signingKeyID</em>&nbsp;</td><td>the key id of the key pair to sign with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signingKeyLocator</em>&nbsp;</td><td>the key locator to use if we save this key (if it is not already published). If not specified, we look for the default locator for the signing key. If there is none, and we are signing with the same key we are publishing, we build a self-referential key locator, using the name passed in (versioned or not). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flowController</em>&nbsp;</td><td>flow controller to use. If non-null, saveType is ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>saveType</em>&nbsp;</td><td>-- if we don't want to hand in a special-purpose flow controller, set saveType to RAW or REPO to get standard publishing behavior. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle to use if we haven't specified a flow controller. Makes a flow controller of the type specified by saveType. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyManager</em>&nbsp;</td><td>the key manager to use to pull additional signing information (default keys and locators if not specified). If null, taken from handle. Also publish key added to its cache. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the published information about this key, whether we published it or someone else had </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9dbc7983a641c7df5b48e652748da59"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::respondToKeyRequests" ref="f9dbc7983a641c7df5b48e652748da59" args="(ContentName keyPrefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.KeyManager.respondToKeyRequests           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>keyPrefix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Right now KeyServers are hidden in our subclasses. 
<p>
... this makes it hard to expose control of filter registration. This is a bad attempt at an API for that, it should change. Don't make it abstract as subclasses may not need it. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#0c5cf2a5a805786036db83e475a57170">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="63fb9107967123fc7add2a6a69f78115"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::getAccessControlManagerForName" ref="63fb9107967123fc7add2a6a69f78115" args="(ContentName contentName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1_access_control_manager.html">AccessControlManager</a> org.ccnx.ccn.KeyManager.getAccessControlManagerForName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>contentName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handle access control manager cache. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contentName</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1keys_1_1_basic_key_manager.html#68f11725957a16bf4447981a432ad9aa">org.ccnx.ccn.impl.security.keys.BasicKeyManager</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="8c9103e88fbe49c1a140446e88a9ca44"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::DEFAULT_DIGEST_ALGORITHM" ref="8c9103e88fbe49c1a140446e88a9ca44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#8c9103e88fbe49c1a140446e88a9ca44">org.ccnx.ccn.KeyManager.DEFAULT_DIGEST_ALGORITHM</a> = &quot;SHA-256&quot;<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Currently default to SHA-256. 
<p>
Only thing that associates a specific digest algorithm with a version of the CCN protocol is the calculation of the vestigial content digest component of ContentName used in Interest matching, and publisher digests. Changing the latter is handled by backwards-compatible changes to the protocol encoding. All other digests are stored prefaced with an algorithm identifier, to allow them to be modified. We expect the protocol default digest algorithm to move to SHA3 when defined. 
</div>
</div><p>
<a class="anchor" name="5e6db34a1a4e19c1f8496a38a54563ac"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::_defaultKeyManager" ref="5e6db34a1a4e19c1f8496a38a54563ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html">KeyManager</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#5e6db34a1a4e19c1f8496a38a54563ac">org.ccnx.ccn.KeyManager._defaultKeyManager</a> = null<code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The default <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html" title="Top-level interface for managing our own keys, as well as maintaining an address...">KeyManager</a> for this user/VM pair. 
<p>
The <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html" title="Top-level interface for managing our own keys, as well as maintaining an address...">KeyManager</a> will eventually have access to significant cached state, and so a single one should be shared by as many processes within the same trust domain as possible. We might make multiple KeyManagers representing different "users" for testing purposes. 
</div>
</div><p>
<a class="anchor" name="11ff3dc4a455536a93ead43cf77b053c"></a><!-- doxytag: member="org::ccnx::ccn::KeyManager::_verifier" ref="11ff3dc4a455536a93ead43cf77b053c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_content_verifier.html">ContentVerifier</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_key_manager.html#11ff3dc4a455536a93ead43cf77b053c">org.ccnx.ccn.KeyManager._verifier</a> = null<code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A default verifier to use, relative to these key caches and all. 
<p>
Move to <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_trust_manager.html" title="Basic interface to trust management -- determination of whether a piece of content...">TrustManager</a> eventually. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/KeyManager.java</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Sep 14 12:44:25 2011 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
